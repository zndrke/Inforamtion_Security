# 시스템 보안

## 1. 시스템 기본학습

### 1. 윈도우 기본

#### 1. 윈도우 인증과정

![image-20210326193213610](https://user-images.githubusercontent.com/45009100/112626943-4599f400-8e74-11eb-8c41-36af09787f74.png)

1. 윈도우 인증 구성요소

   1. **LSA**(Local Security Authority)
      - 모든 계정의 로그인에 대한 검증 및 시스템 자원(파일)에 대한 **접근 권한을 검사**(로컬 및 원격 로그인)
      - 계정명과 SID(Security ID)를 매칭하여 SRM이 생성한 **감사 로그를 기록**
      - NT 보안의 중심 서비스이며 **보안 서브시스템**(Security Subsystem)이라고 불림
   2. **SAM**(Security Account Manager)
      - 사용자/그룹 **계정 정보에 대한 데이터베이스를 관리**
      - 사용자 로그인 정보와 SAM 파일에 저장된 사용자 패스워드 정보를 비교해 인증 여부를 결정
      - SAM 파일은 사용자,그룹 계정 및 암호화된 **패스워드 정보를 저장하고있는 데이터베이스**로
      - 윈도우 설치 디렉터리(c:\\innt 또는 c:\\Windows)에 위치함
   3. **SRM**(security Reference Monitor)
      - 인증된 사용자에게 **SID를 부여**
      - SID를 기반으로 하여 파일이나 디렉터리에 대한 **접근을 허용할지 여부를 결정**하고 이에 대한 **감사 메시지를 생성**

2. 로컬인증

   ![image-20210326194723616](https://user-images.githubusercontent.com/45009100/112626982-564a6a00-8e74-11eb-990a-f1950abfedbe.png)

3. 원격(도메인) 인증![image-20210326194953512](https://user-images.githubusercontent.com/45009100/112627014-62cec280-8e74-11eb-97a9-3c63886a5d22.png)

4. SAM 파일 접근 통제 설정(시스템 취약점 분석·평가 항목)

   1. SAM 파일은 사용자/그룹 계정의 패스워드를 관리하고 LSA를 통한 인증을 제공하는 중요한 파일이므로 접근통제 필요
   2. 공격자로부터 SAM 파일에 대한 패스워드 공격 시도에 따른 정보 노출의 위험이 있음
   3. 보안설정
      - Administrators 및 System 그룹 외에는 SAM 파일에 대한 접근을 제한
      - 불필요한 그룹 및 계정에 대해서는 권한을 제거

#### 2. 윈도우 보안 식별자(SID : Security ID)

1. 개요
   1. 윈도우의 각 사용자나 그룹에 부여되는 고유한 식별번호
   2. 사용자가 로그인을 수행하면 **액세스 토큰이 생성**되며, 해당 토큰에는 로그인한 사용자와 그 사용자가 속한 **모든 작업 그룹들에 관한 보안 식별자(SID) 정보가 담겨있음**
   3. 액세스 토큰의 사본은 그 사용자에 의해 시작된 모든 프로세스에 할당됨
   4. 사용자 계정 및 패스워드 정보를 담고있는 SAM 파일에 SID정보가 저장되어 있음
2. SID 구조
   1. 계정별 SID 구조
      - S-1-5-21-1700005937-0000000000-2235396725-1001
      - S-1 : 윈도우 시스템을 의미
      - 5-21 : 시스템이 도메인 컨트롤러 이러나 단독 시스템임을 의미
      - 1700005937-0000000000-2235396725 : 해당 시스템만의 고유한 식별자. 윈도우를 다시 설치해도 동일한 값을 가지지 않음
      - 500,501,1000
        - 500 : 관리자
        - 501 : 게스트
        - 1000 : 일반 사용자
   2. 실습
      - 윈도우 관리명령 콘솔(WMIC) 에서 확인 가능
      - cmd > wmic > useraccount list brief

#### 3. 윈도우 인증구조

![image-20210326202027193](https://user-images.githubusercontent.com/45009100/112627052-6febb180-8e74-11eb-99eb-a6654d15f2b0.png)

1. 개요
   1. 단순히 아이디와 패스워드를 전달하여 인증하는 방식은 정보 노출 및 패스워드 재사용공격에 취약
   2. 윈도우는 **Challenge & Response 방식** 의 인증구조를 사용
      1. 인증요청
         - 인증하고자 하는 사용자가 윈도우 시스템에 인증 요청
      2. Challenge 값 생성 및 전송
         - 인증 요청을 받은 서버는 특정 규칙 또는 랜덤한 Challenge 값을 생성하여 사용자에게 전달
      3. Response 값 생성 및 전송
         - 사용자는 전달받은 Challenge 값과 사용자 패스워드 정보를 이용해 Resonse 값을 생성하여 서버에 전달
      4. Response 값 확인 및 인증 성공
         - 사용자가 전달한 Response 값을 확인하여 인증 성공 여부를 전달
2. 인증암호 알고리즘
   1. LM(Lan Manager) 해시
      - 윈도우 2000,XP의 기본 알고리즘으로 구조적으로 취약
   2. NTLM 해시 
      -  LM 해시에 MD4 해시가 추가된 형태
   3. NTLMv2
      - 비스타 이후 윈도우 시스템의 기본 인증 프로토콜
      - 기존의 알고리즘과 전혀 다른 알고리즘으로 해시값을 생성, 크래킹이 어렵다
   4. Lan Manager는 네트워크를 통한 파일 및 프린터 공유 등과 같은 작업시 인증을 담당
   5. LM 인증 수준 설정을 통해 Challenge & Response 인증 프로토콜을 결정하면 NTLMv2 사용을 권장

#### 4. 패스워드 크래킹

1. 사전대입 공격(Dictionary Attack)
   - 패스워드로 자주 사용되는 사전에 있는 단어, 키보드 자판의 일련순 등 미리 사전(Dictionary) 파일로 만든 후 이를 하나씩 대입하는 방법
2. 무작위 대입 공격(Brute Force)
   - 패스워드에 사용될 수 있는 문자열의 범위를 정하고, 그 범위내에서 가능한 모든 패스워드를 대입
   - 일반적으로 사전공격 실패 후 무차별공격을 진행
3. 혼합 공격(hybrid Attack)
   - 사전대입 공격과 무작위 대입공격을 혼합한 방식
   - 사전파일에 있는 문자열에 문자, 숫자 등을 추가로 무작위 대입하는 크래킹 방법
   - 일반적으로 사전에 나오는 문자열 뒤에 숫자를 추가하는 형태의 패스워드가 많은점을 악용
4. 레인보우 테이블
   - 레인보우 테이블은 하나의 패스워드에서 시작해 특정한 변이함수를 이용해 여러 변이된 형태의 패스워드를 생성
   - 각 변이된 패스워드의 해시를 고리처럼 연결하여 일정 수의 패스워드와 해시로 이루어진 체인을 무수히 만들어 놓은 테이블
   - 해시 테이블과 R(Reduction)함수의 반복 수행을 통해 일치하는 해시값을  통해서 패스워드를 찾아내는 방식
   - 즉, 가능한 모든 해쉬값을 저장해 놓은 표. 해시로의 변환이 필요 없어 매우 빠름
   - 레인보우테이블로 인해 12자리의 숫자, 10자리의 소문자, 8자리의 숫자+소문자 정도는 순식간에 뚫을 수 있음
   - 방어법은
     - PBKDF2, Bcrypt,Scrypt 등의 적절한 알고리즘
     - 영어, 숫자, 특수문자를 조합한 긴 암호
     - 반복된 로그인 차단
     - 2-factor 인증
     - OTP 사용
     - Salted Hash



### 2. Unix/Linux 기본

#### 1. 시스템 기본

1. 시스템 접근

   1. 로그인 과정
      - 사용자 계정과 패스워드를 입력하면 로그인을 담당하는 프로그램은 입력한 패스워드와 /etc/passwd 파일의 해당 필드와 비교
      - 패스워드 확인 후 로그인 프로그램은 쉘이 사용할 변수들을 근거로 초기 환경을 설정. HOME, SHELL, USER, LOGNAME 변수들은 /etc/passwd파일에 기록된 정보로 값이 설정
        - HOME : 사용자의 홈 디렉터리 지정
        - SHELL : 로그인 쉘 지정
        - USER 또는 LOGNAME : 사용자의 사용자계정을 지정
      - 모든 절차가 끝나면 로그인 쉘 실행
      - 로그인 쉘은 일반적으로 etc/passwd 파일의 마지막 필드에 지정. 쉘은 사용자가 입력한 명령어를 해석하고 처리하는 기능을 함
   2. 로그아웃
      - 로그아웃 명령어는 logout 과 exit이 있고 [cntl + d] 조합으로도 가능

2. 사용자정보

   1. /etc/passwd 파일

      1. UNIX는 시스템 관리자가 사용자 계정을 만들 때마다 해당 사용자와 관련된 정보를 etc/passwd 파일에 저장

      2. passwd 파일에는 UNIX 시스템을 이용하는 데 필요한 기본 정보들이 담겨있음. 구분자 : 를 이용하여 7개의 필드로 구성

      3. 형식

         [1.user_account] : [2.user_password] : [3.user_id] : [4.group_id] : [5.comment] : [6.home_directory] : [7.login_shell]

         1. 사용자의 계정명
         2. 사용자 패스워드(x는 shadow 패스워드를 사용한다는 의미)
         3. 사용자 ID
         4. 그룹 ID
         5. 사용자 관련 기타 정보
         6. 로그인에 성공한 후에 사용자가 위치할 홈 디렉토리
         7. 로그인 쉘

      4. 해킹시 주로 3,4 번을 0으로 변경. root가 아니더라도 UID,GID가 0이 되면 root가 됨

      5. UID,GID가 0으로 변경된 계정이 있는지 주기적으로 관리해야 함. 또한 7번을 변경하여 악성 쉘이 실행되는 경우도 있음

   2. 사용자 확인

      1. UNIX 시스템에 접속중인 사용자를 확인하려면 id 명령을 사용
      2. 문법
         - id [user_account]
         - id만 하면 실행한 사용자 확인
         - id 뒤에 계정을 추가하면 계정의 id 확인

   3. 패스워드 변경

      1. 사용하던 패스워드를 변경하거나 패스워드가 없는 사용자에게 패스워드를 부여할 때 passwd명령을 사용
      2. 일반사용자는 자신의 패스워드만 변경,  root는 모든 사용자의 패스워드를 변경 가능
      3. 문법
         - passwd [user_account]

3. 그룹정보

   1. 그룹명과 그룹ID

      - 접근권한 및 보안 등의 관리를 위하여 사용자와 그룹에 대한 식별이 필요

      - 사용자ID와 그룹ID는 사용자와 그룹을 식별하는 시스템의 유일한 정수값

   2. 기본그룹과 보조그룹

      - UNIX 시스템은 자원의 소유주가 소속된 그룹에 별도의 접근권한을 지정할 수 있음
      - 같은 그룹에 소속된 사용자는 자원에 대하여 동일한 접근권한을 가짐
      - 하나의 기본그룹과 복수의 보조그룹에 소속될 수 있음
      - 기본그룹은 사용자가 자원 생성시 해당자원의 소유그룹을 지정하는 데 사용되며 etc/passwd 파일의 4번째 필드에 명시

   3. /etc/group 파일

      - 현재 시스템에 정의되어 있는 모든 그룹의 정보를 저장하고 있음

      - 형식

        	- [1.group_name] : [2.unvariable] : [3.group_id] : [4.user_account_entry_in_group]

        1. 그룹명
        2. 그룹의 암호화된 패스워드(사용안함)
        3. 기본그룹 ID로 그룹명을 대신하는 정수형 숫자
        4. 소속된 사용자 계정들

4. 입출력 재지정(I/O Redirection)

   - 입출력 대상으로 표준입력, 표준 출력, 표준 에러를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 말함
   - 키보드(표준입력)에서 들어오는 입력을 파일에서 받도록 대체하는 것을 입력재지정 이라고 함
   - 명령의 실행결과나 에러상황(표준출력,표준에러)을 화면에 출력하지 않고 파일로 대체하는 것을 출력 재지정
     - 입력 재지정 : command > file_name
     - 출력 재지정 : 
       1. command < file_name(파일 존재 시 새롭게 출력)
       2. command << file_name (파일 존재 시 추가하여 출력)

5. 파이프

   - 둘 이상의 명령을 함께 묶어 출력의 결과를 다른 프로그램의 입력으로 전환하는 기능
   - 명령어와 명령어 연결은 "|"를 사용하고, 선행 명령의 출력 데이터가 후행 명령의 입력데이터로 전달
   - command1 | command2 [ | command3 ...]

6. 특수문자

   - ~ : 홈 디렉터리
   - . : 현재 디렉터리
   - .. : 상위 디렉터리
   - ''#'': 주석
   - $ : 쉘 변수
   - & : 백그라운드 작업
   - "*" : 문자열 와일드 카드
   - ? : 한문자 와일드카드
     - ?는 한글자 *는 전체글자를 의미
     - ?a?는 가운데가 a인 세글자를 의미
     - a*a는 a로 시작하고 a로 끝나는 단어를 의미
   - ; : 쉘명령 구분자
   - | : 파이프
   - < : 입력 재지정
   - ">" : 출력재지정

#### 2. 파일시스템 응용

1. 파일시스템 개요

   1. 개요
      - 물리적인 저장장치에 파일을 생성, 저장, 관리하기 위한 논리적인 자료구조
      - 물리적인 디스크는 논리적인 파티션으로 나누어지며, 각각 파티션 별로 고유한 피일시스템을 생성
   2. 파일시스템 구정
      1. 부트블럭
         - 운영체제를 부팅하거나 초기화하기 위한 부트스트랩 코드를 담고있는 블럭
      2. 슈퍼블럭
         - 해당 파일시스템을 관리하기 위한 정보를 담고 있는 블럭
      3. 아이노드 리스트
         - 파일시스템 내에서 해당 파일을 식별하기 위한 고유한 식별자
         - 파일에 대한 속성 정보를 구조체 리스트로 이루어져 있음
         - i-node는 파일명이 없으며, 파일명은 디렉터리를 통해 관리
         - 침해사고 발생시 무결성 확인을 위해 타임라인 분석을 수행. inode의 mac 타임을 점검
           - Last Modification Time : 파일의 내용을 마지막으로 수정한 시간 
           - Last Access Time : 파일을 마지막으로 접근한 시간
           - Last Change Time : 파일의 속성을 마지막으로 변경한 시간
         - 특정 파일의 inode에 대한 속성정보는 stat 명령을 통해 확인
      4. 데이터 블럭
         - 실제 파일의 내용이 저장되는 블럭
         - 고정크기 block들로 이루어져 있다.

2. 파일시스템과 링크파일

   1. 개요
      - 링크는 윈도우의 바로가기 아이콘처험 기존 파일에 대한 또 다른 접근 포인트를 만들어 줌
      - 링크에는 하드링크와 심볼릭 링크가 있음
      - 문법
        - ln [-s] source_file | source_directory target_file
      - 하드링크는 파일에만 링크하고, 심볼릭 링크는 파일 또는 디렉토리에 링크함
   2. 하드링크
      - 하드링크는 기존 파일과 동일한 inode number를 가지는 파일을 생성하여 접근하는 방식
      - inode number는 파일시스템 별로 고유한 값이기 때문에 동일 파일시스템 내에서만 하드링크가 가능하고, 디렉터리는 하드링크가 불가능함
      - inode를 참조하는 파일이 있으면 삭제하지 않음
      - stat 을 통해 inode 정보를 확인
   3. 심볼릭 링크
      - 동일한 파일시스템 내에서만 링크가 가능한 하드링크의 단점을 보완
      - 원본 파일에 대한 파일 경로를 파일내용으로 하는 새로운 파일을 생성해서 접근
      - 하드링크와 달리 파일경로를 기반으로 하므로 파일시스템에 제한이 없고 디렉터리도 가능
      - 원본파일이 삭제되거나 이동하게 되면 해당 경로가 바뀌게 되므로 링크가 끊어짐

3. 디렉터리 관리

   1. 파일의 종류
      1. 일반 파일 
         -  일반적으로 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 되어있음
         - 정규파일은 표준 파일 입출력 시스템 호출을 통해 참조
      2. 디렉터리
         - 디렉터리에 포함된 파일명과 해당 파일에 대한 정보를 담고있는 inode number 목록을 내용으로 가지고 있는 특수한 파일
      3. 특수파일
         - 기능에 따라 다양한 형태로 존재
         - 프로세스 간 통신을 위해 **파이프**, **소켓** 등의 파일을 사용
         - 디스크, 프린터, 터미널, 키보드 등의 주변장치를 사용하기 위한 **장치파일**
         - 장치파일은 블럭단위로 입출력하는 블럭 장치 파일(버퍼링)과 문자단위로 입출력하는 문자 장치 파일(비 버퍼링)으로 구분
   2. 디렉터리 내용 출력(ls 명령)
      - 특정 디렉터리에 있는 파일 목록을 보여주고 옵션 정보를 보여줌
      - 디렉터리에는 파일명과 해당 파일의 inode number에 대한 매핑정보만 가지고 있으며, 상세정보를 볼 수 있는 것은 inode number를 통해 inode 구조체 정보를 참조하기 때문
   3. 디렉터리 간의 이동 (cd 명령)
      - change directory
   4. 새로운 디렉터리 생성(mkdir 명령)
   5. 기존 디렉터리 삭제(rmdir 명령)
      - 디렉터리 하위에 디렉터리나 파일이 없어야 함

4. 파일권한 관리

   1. 접근권한 변경(chmod 명령)
      - 기존 파일 또는 디렉터리에 대한 접근권한을 변경할 때 사용
      - 접근권한을 기호로 기술하는 방법
        - 대상 : u(user), g(group), o(others) , a(all)
        - 연산자 : +(추가), -(제거), =(지정)
        - 접근권한 : r,w,x
      - 접근권한을 숫자로 기술하는 방법
        - 읽기 = 4, 쓰기 = 2, 실행 = 1
        - 644 : user는 읽기&쓰기 , group과 others는 읽기만 가능
   2. 소유주 또는 소유그룹 변경(chown / chgrp)
      - root는 모든 소유자/소유그룹 변경 가능
   3. 접근권한 마스크(umask)
      - 기존 파일의 접근권한을 변경할 때 사용. 8진수로 해당 파일의 권한을 명시
      - 8진수의 의미는 새로 만들어질 파일에서 제거 될 권한을 명시
      - 즉, umask 022로 설정하면 생성되는 파일은 666 - 022 인 644의 권한으로 생성됨

5. 파일검색 (find)

   - find명령은 시스템 내에있는 파일 중에서 사용자가 원하는 파일을 찾을 때 사용
   - 단순히 찾을 뿐만 아니라 특정 명령을 실행하도록 명력할 수 있어서 편리함

   1. 주요 옵션 실습
      1. 퍼미션 관련
         - -perm [-]mode : -가 없으면 정확히 모드 권한과 일치하는 파일, -가 있으면 mode 권한을 포함하는 파일을 검색
         - -perm 4000 이면 setuid만 설정되어 있는 파일을 검색하고, -4000이면 setuid를 포함하는 파일을 검색
         - -exec 옵션을 통해 추가적인 명령을 싱행
         - 검색조건이 둘 이상일 경우 -o(or) -a(and)의 논리연산 및 ()를 추가하여 우선순위 지정
      2. **시간 관련 실습**
         - 파일 시간 속성에 따라 atime(accss time), mtime(moditication time), ctime(change time) 으로 구분
         - -mtime [+-]n : +-가 없으면 정확이 n일, +n이면 n일 초과, -n이면 n일 미만인  파일을 검색
         - -mtime -4 이면 마지막 수정일이 4일 미만인 파일을 검색
      3. 크기 관련 실습
         - size [+-]n : 사이즈가 초과/미만인 파일을 검색
         - size +3M : 크기가 3Mbytes를 초과하는 파일을 검색

#### 3. 프로세스 응용

1. 프로세스 개요
   1. 개요
      1. 프로세스가 생성되면 커널/운영체제는 개별 프로세스별로 관리정보를 담고있는 프로세스 제어 블럭 PCB를 생성
         - 프로세스 상태 : 프로세스의 현재 상태정보를 저장
         - 프로세스 번호 : 프로세스를 식별하기 위한 번호ID
         - 프로그램 카운터 : 문맥교환이 발생할 경우 다음에 실행할 명령어의 위치를 저장
         - 레지스터 : 문맥교환이 발생할 경우 현재 프로세스의 실행 상태정보를 저장
         - 메모리 정보 : 프로세스가 사용하는 메모리 page 또는 segment 테이블 정보
      2. 프로세스가 생성되면 개별 프로세스별로 오픈한 파일을 관리하기 위한 파일 디스크립터 테이블(FDT)이 생성된다
         - 기본적으로 3개의 파일이 자동 오픈됨. 표준입력, 표준출력, 표준에러
         - 프로세스 내에서 오픈한 각각의 파일을 식별하기 위한 양의 정수값을 파일 디스크립터라고 함
      3. 커널/운여영체제가 시스템 내에서 여러 프로세스들에 의해 오픈된 파일들을 관리하기 위한 자료구조가 System open-file tables
         - open_mode : 파일의 읽기/쓰기 모드
         - offset : 현재 파일 I/O를 수행하기 위한 위치값
         - reference_count : 해당 파일의 참조 개수를 의미. 파일 복제가 발생하면 count가 증가
      4. Active vnode table은 해당 파일의 inode 정보를 가지고 있는 일종의 캐시역할을 함

### 3. Unix/Linux 시스템 관리

1. 시스템 시작과 종료
   1. 부팅관련 용어 정의
      1. Run Level
         - 시스템에서 런레벨의 의미는 시스템의 운영상태를 숫자 혹은 문자로 표현
         - init 프로세스는 /etc/inittab 파일에 정의된 런 레벨에 따라 디렉터리에 나열도니 스크립트를 실행하여 시스템의 운영상태를 구성
         - 각 런레벨이 의미하는 시스템의 운영상태
           - 0 : PROM(Programmable Read-Only Memory)
           - S,s : 시스템 싱글 유저 모드, 로컬 파일 시스템이 마운트되지 않은 상태
           - 1 : 시스템 싱글 유저 모드, 로클 파일 시스템이 마운트된 상태
           - 2 : 멀티유저 모드 (NFS 클라이언트 모드)
           - 3 : 멀티유저 모드 (NFS 서버 모드), UNIX 기본 Run Level
           - 4 : 사용안함
           - 5 : 시스템 power off 모드
           - 6 : 시스템 리부팅
         - 서버용 Unix 시스템은 일반적으로 3 또는 5의 런레벨로 운영됨
         - 현재 운영중이 런레벨을 알고슾은 경우 who -r 또는 runlevel 명령
      2. INIT 상태
         - 시스템 런레벨을 이동할 때, init 명령어를 통해 이동
         - 현재 멀티유저모드인 3인데, 싱글모드로 이동하고 싶은 경우 'init s' 명령어를 이용
   2. 시스템 시작
      1. 바이오스 과정
         - 시스템에 전원이 들어오면 바이오스는 시스템의 기본적인 하드웨어의 이상유무를 점검하고 시스템의 하드웨어 정보를 수집
      2. 부트 프로그램 과정
         - 부트 프로그램은 하드디스크에서 커널을 읽어 들여 메모리상에 적재하고 시스템 제어권을 커널에 넘김
      3. 커널 과정
         - 커널이 메모리상에 적재되면 그때부터 운영체제가 구동되기 시작
         - 커널은 부팅과정의 일부인 하드웨어 점검을 완료하고 내부 자료구조를 초기화하여 시스템을 운영하기 위한 부가적인 커널 모듈을 하드디스크에서 메모리 상으로 적재함
      4. init 프로세스 과정
         - init 프로세스는 커널에 의해 생성되는 첫 프로세스
         - 부팅과정에서 사용자가 시스템을 사용할 수 있게 하는 초기화 담당
         - 런레벨이라고 함
2. 사용자 관리
   1. 사용자 계정 추가
      - 사용자 계정정보를 저장하는 /etc/passwd 와 암호를 저장하는 /etc/shadow에 사용자정보를 저장
      - 새 사용자를 위한 홈 디렉터리를 생성하고 접근권한 부여
      - 사용자 로그인에 필요한 시작파일을 홈 디렉터에 생성
3. 파일시스템 관리
   1. 파일시스템 연결
      - 보조기억장치에 들어있는 데이터를 읽어오고, 저장하려면 UNIX시스템에 연결해야 함
      - mount 명령으로 보조기억장치를 UNIX 시스템이 인식하도록 특정 디렉터리에 논리적으로 연결
4. 프로세스 스케줄관리
   1. 정기적 스케줄관리(cron)
      1. 개요
         1. cron 데몬 프로세스는 시스템에서 정기적인 작업을 지정시간에 처리하기 위해 사용
         2. 데몬 프로세스를 통한 처리가 효율적인 작업
            - 일괄적으로 처리해야 하는 작업(특히 야간작업)
            - 작업에 대한 요구가 불규칙하지 않은 경우
            - 우선순위가 낮은 작업을 일정시기에 처리해야 하는 경우
            - 작업 빈도가 낮아서 필요시점에 처리하는 것이 효율적
         3. cron 데몬 프로세스를 사용하려면 세가지 구성요소가 필요
            1. 정기적으로 처리할 작업 목록을 정의한 crontab 파일
            2. crontab 파일을 제어하는 crontab 명령
            3. crontab 파일을 읽어서 내용에 정의된 대로 작업을 처리하는 cron 데몬 프로세스
      2. crontab 파일의 구조
         1. crontab 파일의 각 행은 space나 tab 키로 구분된 6개의 필드
            1. 필드1 : 분
            2. 필드2 : 시
            3. 필드3 : 일
            4. 필드4 : 월
            5. 필드5 : 요일
            6. 필드6 : 작업
      3. crontab 파일의 제어
         1. crontab 파일은 사용자 계정별로 만듦
         2. 시스템 관리자인 root는 다른 사용자의 crontab 파일을 편집할 수 있음
         3. 입력문법
            - 리눅스 : $crontab -u algisa (-e | -l | -r )  (편집,출력, 삭제)
            - 유닉스 : $crontab (-e | -l| -r) algisa
            - 자신의 계정 : $crontab (-e | -l | -r)
      4. crontab 명령 접근제어
         1. crontab 명령을 실행할 수 있는 사용자를 제한하여 임의로 등록하지 못하게 함
         2. crontab 명령 접근 제어를 위해 /etc/cron.allow , /etc/cron.deny 설정파일을 사용
         3. cron.allow 는 등록된 사용자만 명령을 실행하는 화이트리스트 방식
         4. cron.deny는 등록된 사용자만 할 수 없는 블랙리스트 방식
         5. 두 파일이 모두 존재하는 경우 cron.allow를 우선으로 함
         6. 두 파일 모두 없는 경우 root만 명령을 실행할 수 있음
   2. 일시적 스케줄관리(at)
      - 한번만 실행, 처리된 작업은 작업 목록에서 삭제

### 4. Unix/Linux 서버 보안

1. 시스템 보안
   1. 사용자의 패스워드 관리
      1. 개요
         - passwd 파일은 시스템에 등록된 사용자 정보가 담겨있음
         - 패스워드 저장정책에는 passwd와 shadow 가 있음
         - 과거에는 passwd파일의 두번째 필드에 저장했으나, 최근에는 shadow 파일에 암호화된 패스워드를 저장하고 root만 접근가능
      2. passwd 파일
         - 사용자 로그인 쉘 점검
         - 사용자의 로그인 쉘을 /sbin/nologin 또는 /bin/false 로 설정
      3. shadow( etc/shadow) 파일 (리눅스 기준)
         1.  개요
            - 패스워드 정보를 평문으로 저장할 경우 유출 피해가 발생할 수 있음
            - 따라서 암호화하여 저장하고 root만 접근 가능하도록 함
         2. /etc/shadow 파일 형식
            1. user_account : 사용자 계정명
            2. encrypted_password : 암호화된 패스워드
            3. last_change : 1970년 1월 1일 기준으로 마지막으로 패스워드를 변경한 일 수
            4. minlife : 패스워드 최소 사용기간 설정. 익숙한 암호 재사용 방지 7일 권장
            5. maxlife : 패스워드 최대 사용기간 설정. 패스워드 만료일수 90일 권장
            6. warn : 패스워드 만료이전 경고 일수
            7. inactive : 패스워드가 만료된 이후 계정이 잠기기 전까지 비활성 일수
            8. expires : 계정 만료일 설정 1970년 1월 1일 기준으로 일수로 표시
         3. encrypted_password 필드 구성
            - ID,Salt,encrypted_password 형식으로 구성
            - ID는 암호화에 적용된 일방향 해시 알고리즘을 식별하기 위함. 1 : MD5 ,2 : BlowFish, 5 : SHA-256, 6 : SHA-512
            - 솔트는 패스워드 강화를 위한 임의의 랜덤값으로 사용자의 패스워드에 추가하여 암호를 생성
            - 솔트를 통해 레인보우 테이블 공격에 대응할 수 있다
            - encrypted_password는 사용자 패스워드에 솔트를 조합하여 해시한 해시값, 즉 암호화된 패스워드를 말함
         4.  패스워드 저장정책 변경
            - pwconv 명령어 : 사용자 계정 패스워드 저장 정책을 shadow 패스워드 정책으로 변경
            - pwunconv 명령어 : 사용자 계정 패스워드 저장 정책을 일반 패스워드(passwd 파일)으로 변경하는 명령어
      
   2. 프로세스 실행권한
      1. 유닉스/리눅스 시스템에서 접근권한을 판단하는 ID로 RUID,RGID,EUID,EGID 각 있다.
        
         - R은 실제, E는 실행중에만 부여되는 
         
         - RUID : 프로세스를 실행시킨 사용자의 UID
         - RGID : 프로세스를 실행시킨 사용자의 GID
         - EUID : 프로세스가 실행중인 동안에만 부여되는 UID로 자원 접근 권한을 판단하기 위한 UID로 사용
         - EGID : 프로세스가 실행중인 동안에만 부여되는 GID로 자원 접근 권한을 판단하기 위한 GID로 사용
         
      2. SUID(set UID), SGID(set GID)는 프로세스가 실행중인 동안에 해당 실행파일의 소유자, 소유그룹의 권한으로 자원에 접근할 수 있도록하는 권한설정이다
      
         - SUID, SGID가 설정되지 않은 프로세스는 RUID와 EUID, RGID와 EGID가 동일하게 설정
         - 사용자의 GID로 RGID, EGID가 설정되므로 사용자의 권한으로 자원에 접근
         - SUID,SGID가 설정된 프로세스는 실행시킨 사용자와는 무관하게 플세스가 실행중인 동안에는 실행파일 소유자의 권한으로 자원 접근
      
      3. 특수권한 비트(SUID,SGID) 설정
      
         - 특수권한 3bit
           - s(suid) : 4 , s(sgid) : 2, t(sticky-bit)  : 1
         - user 
           - r : 4 , w : 2, x : 1
         - group
           - r/w/x
         - other
           - r/w/x
         - 예를들어, 755권한의 a.out 파일에 suid 설정 : chmod 4775 a.out
         - suid, sgid 설정 : chmod 6775 a.out
      
      4. 만약 root 소유의 자원에 대해 일반 사용자의 직접 접근을 차단하면서 기능상 필요한 부분만을 접근하도록 허용할 필요가 있는 경우 별도의 root 소유 프로그램을 통해 suid,sgid를 설정하여 사용하는 것이 보안적, 운영적으로 효율적이다. 다만, root권한이 필요없는 프로그램인데 소유주가 root로 되어있는 경우 보안상으로 취약함
      
         - 대표적으로 일반 사용자가 패스워드 변경을 위해 passwd 명령어를 쓰는 경우
         - passwd 명령어는 root 소유의 실행파일로 suid, sgid가 설정되어 있기 때문에 root만 접근 가능한 /etcc/shadow 파일에 접근하여 패스워드를 변경할 수 있다.
      
      5. root 소유 SUID, SGID 실행파일 주기적 검사
      
         - find 명령의 -perm 옵션을 이용하여 -4000(suid) 또는 -2000(sgid) 인 파일을 검사할 수 있다.
         - 검사 명령어 : **find / -user root -type f \( -perm -4000 -o -perm -2000 \) -exec ls -al {}\;**
         - 소유자가 root이고 파일유형이 일반 파일이고 SUID 또는 SGID가 설정된 파일 정보를 상세 출력
         - 제거 명령어 : chmod -s 실행파일명 (-s 옵션은 suid,sgid 권한을 제거)
      
   3. 디렉터리 접근권한(sticky-bit)
   
      1. 공유디렉터리에서 자유롭게 파일을 생성하되 삭제나 파일명 변경은 소유자만 가능하도록 하는 특수권한비트가 sticky-bit
   
2. 네트워크 보안

   1. 보안 쉘[SSH]

      - 보안 쉘(secure Shell)이란 암호 통신을 이용하여 네트워크 상의 다른 컴퓨터에 접속하여 원격으로 명령을 실행하거나 파일을 조작하는 응용 프로그램 또는 프로토콜을 의미.
      - 암호화된 원격 터미널 서비스 제공
      - 암호화된 파일 송수신 서비스 제공
      - 기존의 rsh, rlogin, Telnet, FTP 등 평문 송수신 서비스의 취약점을 대체하기 위해 설계되었으며, 디폴트로 22/tcp 포트를 사용

   2. 슈퍼 서버[inetd 데몬]

      1. 개요

         - 네트워크 서버/ 클라이언트 구조에서 다양한 서비스의(FTP, Telnet, SSH, HTTP 등) 서버 프로세스(데몬) 동작방식은 공통점이 존재함. 실제 서비스를 제공하는 서비스 프로세스를 제외하고 클라이언트의 요청이 있을 때까지 대기하다가, 요청이 들어오면 요청을 처리할 자식 프로세스를 실행
         - 따라서 효율적인 서버자원의 활용을 위해 공통적인 부분을 처리하는 슈퍼데몬을 만들어 개별 서비스를 등록하게 하여 클라이언트 요청은 슈퍼데몬이 모두 처리하고, 개별서비스를 호출하는 방식을 사용
           - Stand-Alone 방식 : 개별 서비스별로 서버 프로세스가 동작하는 방식으로, 속도가 빠르지만 리소스를 많이 점유함
           - inetd(xinetd) 방식 : 슈퍼데몬을 이용하여 속도는 비교적 느리지만, 서버 리소스를 절약할 수 있음
         - inetd 데몬은 N개의 개별 서버를 하나로 통합하여 클라이언트로부터 서비스 요청이 올때마다 해당 서비스에 관련된 실행모듈(FTP, Telnet, SSH 등)을 실행
         - inetd 데몬은 최초 실행시 /etc/inetd.conf 파일의 정보를 참조하여 서비스할 프로그램들에 대한 정보를 얻는다. 시스템 관리자는 inetd 데몬으로 서비스할 프로그램의 특징을 /etc/inetd.conf 파일에 정의해야 함
         - 리눅스 시스템의 경우 xinetd 데몬을 주로 사용

      2. inetd.conf 파일의 구조

         > ftp	stream 	tcp 	nowait 	root 	/usr/sbin/in.ftpd 	in.ftpd -l -a
         >
         > ​	1		2			3			4			5				6								7

         1. 서비스명 : /etc/services 파일에 등록된 포트번호를 참조하여 서비스할 프로세스의 포트를 결정
         2. 소켓타입 : 해당 서비스에 대한 소켓 유형을 설정. TCP는 stream, UDP는 datagram을 사용
         3. 프로토콜 : /etc/protocols 파일에 주어진 프로토콜 중 사용가능한 프로토콜을 설정. etc/services 파일과 일치해야 함
         4. 플래그 : 즉시 다음 서비스 요청을 처리할 것인지(nowait), 요청처리가 완료될 때까지 기다릴 것인지 설정(wait)
         5. 사용할 사용자 계정 : 프로그램을 실행시킬 사용자 계정
         6. 실행 경로명 : 해당 서비스를 처리하는 실행 모듈의 경로를 절대경로로 설정
         7. 실행 인수 : 프로그램의 인수를 설정. 첫번째는 응용 프로그램 자신의 이름이 됨

      3. 불필요한/취약한 서비스 비활성화

         1. 불필요하고 보안상 취약한 다음 서비스들은 비활성화 한다
            1. Dos 공격에 취약한 Simple TCP 서비스 : echo, discard, daytime, chrgen
            2. r계열 서비스 : rlogin, rsh, rexec 등 인증없이 관리자의 원격 접속을 가능하게하는 명령어들
            3. 불필요한 rpc(remote procedure call) 서비스 : 분산환경에서 서버 응용프로그램에 접근하여 작업 호출을 할 수 있는 서비스로 버퍼 오버플로우 등 침해사고 발생위험
            4. 기타 불필요한 finger, tftp, talk 등의 서비스
         2. 불필요한/취약한 서비스 확인 및 비활성화 처리
            - inetd.conf 파일에서 취약한 서비스를 grep하여 활성화되어있으면 이를 주석(#)처리하여 비활성화
            - inetd.conf 설정을 적용하기 위해서 inetd 서비스를 재시작

   3. 접근 통제 [TCP Wrapper]

      1. 개요

         1. TCP Wrapper는 외부에서 들어오는 클라이언트에 대해 접근통제 기능을 제공한다. 클라이언트의 IP 주고를 확인하여 시스템 관리자가 접근을 허용한 호스트들에 대해서만 서비스를 허용하기 때문에 해킹으로부터 시스템을 보호할 수 있음

         2. 접근허용 및 차단에 대한 판단은 /etc/hosts.allow와 /etc/hosts.deny 파일에 정의된 호스트정보를 기준으로 함

         3. 접근 순서는

            1. hosts.allow를 확인하여 호스트 정보가 있으면 접근을 허용
            2. hosts.dent를 확인하여 호스트 정보가 있으면 접근을 차단
            3. 둘다 호스트 정보가 없으면 default로 모든 접근을 허용

         4. TCP Wrapper를 사용하기 전과 후의 telnet 서비스에 대한 /etc/inetd.conf 파일 구조

            > 사용 전 : ftp	stream 	tcp 	nowait 	root 	**/usr/sbin/in.telnetd** 	in.ftpd -l -a
            >
            > 사용 후 : ftp	stream 	tcp 	nowait 	root 	**/usr/sbin/in.tcpd** 	in.ftpd -l -a

            - TCP Wrapper를 사용할 경우 해당 서비스의 실행경로에 "usr/sbin/tcpd"를 명시함. inetd 데몬은 외부로부터 서비스요청이 들어올 경우 inetd.conf 파일을 참조하여 TCP Wrapper 프로세스를 실행
            - tcpd는 hosts.allow와 hosts.deny를 실행

      2. hosts.allow(접근허용)과 hosts.deny(접근 금지)

         - host.deny 설정을 보면 ALL : ALL로 되어있음. 이는 모든 서비스에 대해서 모든 호스트의 접근을 차단한다는 의미
         - 일반적인 설정이 hosts.allow 파일에 허용할 호스트를 명시한 후 hosts.deny 파일에 그외의 모든 호스트를 차단하도록 함
         - 결과적으로, 먼저 처리되는 hosts.allow 파일에 허용하지 않는 모든 호스트를 차단함

      3. shell_command

         - shell_command 에 정의한 쉘 명령은 접근통제 리스트(ACL)에 일치하는 것이 있으면 실행하는 명령으로, 일반적으로 hosts.deny 파일에 이를 설정하여 차단된 호스트에게 즉시 통보나 경고 메세지를 보내는 용도로 사용
         - 쉘 명령을 실행하는 방법으로는 twist또는 spawn 이 있다. twist는 명령의 결과를 클라이언트에 전송하기 때문에 클라이언트에게 메시지를 보낼때 유용하고, spawn은 명령의 결과를 클라이언트에 보내지 않는다
         - hosts.deny 파일 (일부분)
           - in.telnetd : 192.168.0.104 : **twist** /bin/echo "192.168.0.10는 연결이 거부되었음"
           - 클라이언트에게 메시지를 전송함
           - in.telnetd : 192.168.0.104 : spawn /bin/mail -s "%a is denied" root
           - 연결을 거부하고 "%a is denied" 라는 제목으로 root에게 메일을 전송

3. PAM(장착형 인증 모듈, Pluggable Authentication Modules)

   1. 개요 

      1. PAM은 리눅스 시스템 내에서 사용되는 각종 어플리케이션 인증을 위해 제공되는 다양한 인증용 라이브러리
         - 일반적으로 /lib/security 또는 /usr/lib/security 디렉터리에 해당 라이브러리가 저장
         - 라이브러리는 인증 목적에 따라 선택적으로 사용할 수 있음
      2. 리눅스는 로그인이나 Telnet, FTP 등 각종 프로그램 사용 시 PAM을 통한 인증을 처리. 유연성과 중앙통제가 가능하다는 장점

   2. PAM을 사용한 인증절차 

      1. 각 프로그램은 인증이 필요한 부분에 PAM 라이브러리를 호출
      2. PAM 라이브러리가 호출되면 해당 프로그램의 PAM 설정파일을 참조하여 등록된 PAM 모듈을 수행하고 그 결과를 응용프로그램에 반환
      3. 응용프로그램은 반환된 결과를 이용하여 인증 여부를 결정
      4. PAM 라이브러리 관련 경로
         - /etc/pam.d : PAM 라이브러리를 이용하는 각 응용프로그램의 설정파일이 위치
         - /lib/security : PAM 라이브러리가 제공하는 다양한 인증 모듈이 위치
         - /etc/security : PAM 모듈 실행에 필요한 추가 설정 파일이 위치

   3. PAM 설정파일(/etc/pam.d/remote 설정파일 일부)

      > type	control	module_path	module_arguments

      1. type : PAM 모듈 종류
         - account : 서비스 사용자 계정의 유효성을 검증하는 유형
         - auth : 서비스 사용자 계정의 패스워드 검증 등 사용자 신원을 확인하는 유형
         - password : 서비스 사용자 계정의 비밀번호 설정 및 변경 조건을 지정하는 유형
         - session : 서비스 사용자 계정의 인증처리 전후에 수행할 작업을 지정하는 유형
      2. control : 각 모듈 실행 후 성공 또는 실패에 따른 PAM 라이브러리 행동 결정
         - requisite : 인증에 실패하라 경우 즉시 인증을 거부
         - required : 인증에 실패하더라도 다음 라인의 모듈을 실행하지만 최종결과는 실패
         - sufficient : 이전에 요청된 모듈이 실패하더라도 여기서 성공하면 PAM 인증 성공
         - optional : 모듈의 성공 실패 결과는 모두 무시됨
      3. module_path : PAM에서 사용할 실제 모듈파일이 위치한 경로를 의미. 

   4. PAM 활용 예 1 (시스템 취약점 분석˙평가 항목)

      1. root 계정의 원격 접속 제한
         - root 계정은 시스텀을 관리하는 매우 중요한 계정으로 직접 로그인이 가능하면 불법적인 침입자의 목표가 될 수 있음. 따라서 root계정의 원격 접속을 금지
         - 터미널 접속시 /etc/security 파일에 등록되어 있는 터미널이 아니면 root의 접속을 허용하지 않도록 PAM 설정을 한다
      2. 유닉스/ 리눅스 시스템별 root 계정 원격 접속 제한 설정
         1. SOLARIS 보안설정
            - /etc/default/login 파일의 CONSOLE 라인을 통해 root의 원격 접속을 제한할 수 있다. CONSOLE 라인에 #을 붙이면 외부에서 root 계정으로 접속이 가능하고 #을 붙이지 않으면 콘솔에서만 접근이 가능하다
         2. AIX 보안설정
            - /etc/security/user 파일의 rlogin 설정을 true로 하면 외부에서 root 계정으로 접속이 가능하고 false로 하면 외부에서 접근이 불가능하다
      3. 취약점 점검
         1. w 명령을 통해 현재 접속중인 root 사용자 정보를 확인
            - TTY 컬럼(터미널 타입정보)을 살펴보면, root 계정이 pts 타입으로 접속한 것을 볼 수 있다. pts는 가상 터미널 타입으로 Telnet,터미널 등을 통해 root 계정으로 접속한 것으로 판단할 수 있다.
            - root 계정의 경우 중요한 계정이므로 원격 터미널 접속을 차단하는 것이 필요
      4. SSH(Secure Shell) root 원격 접속 제한 설정
         1. Telnet 또는 FTP를 사용하여 원격 접속 또는 파일 송수신을 할 경우 평문 통신을 하기 때문에 스니핑 공격에 취약함. 이에 대한 대안으로 SSH을 사용할 수 있는데, SSH 암호통신을 이용하는 서비스는 다음과 같다
            - 암호화된 원격 터미널 서비스 (Telnet 기능 대체)
            - 암호화된 파일 송수신 서비스 (FTP 대체)
         2. root 계정의 원격 접속을 제한하기 위한 설정 방법은 다음과 같다
            - /etc/ssh/sshd_config 파일의
            - PermitRootLogin 항목을 no
            - 하고 service sshd restart로 재시작

   5. PAM 활용 예 2

      1. 계정 잠금 임계값 설정
         - 공격자에 의한 패스워드 무작위 대입공격이나 사전대입공격 발생시 암호입력 실패횟수를 적절하게 제한
         - 계정잠금 임계값을 지정하여 초과시 일정시간 잠근다
         - pam_tally2.so 모듈 이용
      2. 계정 잠금 임계값을 설정하기 위해 /etc/pam.d 디렉터리에 있는 system-auth 서비스 설정파일에 pam_tally2.so 모듈을 추가
         - deny = 5 : 5회 입력 실패시 패스워드를 잠금
         - unlock_time=120 : 계정 실패 시간으로 부터 120초 후에 잠금 해제

   6. PAM 활용 예 3

      1. root 계정 su 제한

         - 권한이 없는 일반 사용자가 su 명령을 사용하여 로그인을 시도하고 패스워드 무작위 대입 공격이나 패스워드 추측공격으로 root 권한을 획득 가능
         - su 명령어 사용이 허용된 사용자만 root 계정으로 접속할 수 있도록 설정
         - pam_wheel.so 모듈 이용

      2. sudoers 실습

         > algisa ALL = (ALL) 	NOPASSWD : ALL

         - algisa 계정은 sudo 명령을 통해 모든 호스트에서 root 권한 으로 비밀번호 없이 실행

4. 시스템 로그 설정과 관리

   1. 개요 

      1. 유닉스/리눅스 로그가 저장되는 경로는 시스템 마다 조금씩 다름
         - 일반적으로 유닉스의 경우 /var/adm 디렉터리에 주로 저장됨
         - 리눅스의 경우 /var/log 디렉터리에 저장됨
      2. 리눅스에서는 /var/log 디렉터리에서 시스템의 모든 로그를 기록 및 관리. 시스템의 /etc/syslog.conf 파일에서 시스템 로그 파일들의 위치를 지정하고 있음
      3. 서버에서는 여러 개의 로그 파일이 있으며 이들 로그를 남기는 데몬들 또한 다양함. 시스템 로그데몬(syslogd), 메일데몬(sendmail), 웹데몬(http), 네임서버데몬(named), 슈퍼데몬(xinetd) 등 

   2. # 유닉스/리눅스 주요 로그파일★

      1. utmp(x) 로그파일(리눅스/ 유닉스)

         1. 개요

            - 현재 로그인한 사용자의 상태정보를 담고있는 로그파일
            - binary 파일로 되어있으며 그 내용을 확인하기 위해서는 "w" "who" "finger" 등의 명령어를 이용
            - Linux : /var/run/utmp 
            - Unix : /var/adm/utmpx

         2. "w" 명령 실습

            - 현재 로그인한 사용자

            - USER: 로그인 계정
            - TTY : 터미널 장치 명
            - FROM : 원격 호스트 주소
            - LOGIN@ : 로그인한 시간
            - IDLE : 아무 입력도 수행하지 않은 idle 시간
            - WHAT : 현재 수행하는 작업(명령어)

      2. wtmp(x) 로그파일 

         1. 개요
            - 사용자의 성공한 로그인/로그아웃 정보, 시스템 Boot/Shutdown 정보에 대한 히스토리를 담고 있는 로그 파일
            - binary 파일로 되어 있으며, 그 내용을 확인하기 위해서는 "last" 명령 사용
            - Linux : /var/log/wtmp
            - Unix : /var/adm/wtmpx
         2. "last" 명령 실습
            - "last" 명령을 실행하면 모든 계정에 대한 로그인/로그아웃 정보를 출력
            - last reboot를 통해 Boot/Shutdown 정보도 확인 가능

      3. lastlog 파일

         1. 개요
            - 가장 최근에 성골한 로그인 기록을 담고있는 로그파일
            - binary로 되어 있으며 그 내용을 확인하기 위해서는 
            - 리눅스는 "lastlog" , 유닉스는 "finger" 명령 사용
            - Linux : /var/log/lastlog
            - Unix : /var/adm/lastlog
         2. lastlog, finger 명령 실습
            - "lastlog" 명령을 실행하면 모든 계정의 최근 접속기록을 확인
            - lastlog -u (계정명) 으로 사용자 계정을 지정
            - lastlog -t (일수)로 해당 일수 이내에 접속한 기록을 확인

      4. btmp(리눅스) , loginlog(유닉스)

         1. 개요
            - 실패한 로그인 시도에 대한 기록을 담고 있는 파일
            - Linux : /var/log/btmp - 바이너리 파일로 되어있으며 그 내용을 확인하기 위해서는 lastb 명령을 사용
            - Unix : /var/adm/loginlog - 텍스트 파일로 되어있으며 vi 등 편집기를 통해 로그 내용을 확인

      5. sulog 로그파일 (유닉스)

         1. 개요
            - su(switch user) 명령을 사용한 결과를 저장한 파일(유닉스)
            - 리눅스의 경우 /var/log/secure 로그파일에 su 명령을 사용한 결과가 남음

      6. acct/pacct 로그파일

         1. 개요
            - acct/pacct 로그 파일은 시스템에 로그인한 모든 사용자가 로그아웃할 때까지 입력한 명령어와, 터미널의 종류, 프로세스 시작 시간 등을 저장한 로그
            - binary 파일로 되어 있으며 그 내용을 확인하기 위해서는 "lastcomm" 명령을 사용
            - Linux : var/account/pacct, 기본 생성되는 로그 파일이 아니므로 "accton /var/accout/pacct" 명령 실행 필요
         2. lastcomm 명령 실습
            - 실행한 명령어, 플래그, 사용자명, 터미널 타입, 프로세스 시작 시간을 보여줌

      7. secure 로그 파일(리눅스)

         - 주로 사용자/그룹 생성/삭제, 로그인 등 사용자 인증에 대한 정보를 기록하고 있는 로그파일
         - 원격에서 접속한 내역과 su 명령을 수행한 내역 등이 저장

      8. messages 로그파일(리눅스)

         - 리눅스 시스템의 가장 기본적인 시스템 로그 파일로 시스템 운영에 대한 전반적인 메세지를 저장
         - 시스템 데몬들의 실행 상황 내역, 사용자들의 접속정보, TCP Wrapper 접근 제어 정보 등을 저장

      9. xferlog 로그파일

         - 리눅스 시스템의 FTP 로그 파일로서 proftpd 또는 vsftpd 데몬들의 서비스 내역을 기록하는 파일
         - FTP로 로그인하는 사용자에 대한 로그 기록과 어떤 파일을 업로드/다운로드 하였는가에 대해 상세하게 기록

   3. syslog 설정 관리

      1. 개요
         1. 유닉스 시스템은 syslog 표준 인터페이스를 통해 커널 및 응용 프로그램에 의해 발생하는 로그를 체계적으로 생성하고 관리
         2. 커널 및 응용프로그램이 syslog API를 통해 로그를 생성하면, syslogd 데몬 프로세스가 syslog.conf 설정파일을 참조하여 지정한 로그파일, 콘솔, 외부 서버 등에 로그를 기록
         3. /etc/syslog.conf 파일에 규칙이 정해져있음
         4. 최근 리눅스에서는 기존의 syslog를 개선한 rsyslog를 사용
         5. syslog는 정보보호 특성을 고려하지 않아 UDP를 통해 정보를 전송할 때 공격자가 모니터링 가능
            - 로그전송의 신뢰성을 보장하기 위해 TCP이용을 권고
            - syslog 메시지 전송 시 기밀성을 보장하기 위해 payload를 보호할 수 있는 BEEP을 이용하도록 권고
            - BEEP(Block Extensible Exchange Protocol) 은 연결 지향적이고, 비동기적인 연결을 위한 프로토콜로, 내부적 인증, 프라이버시, 재전송을 통한 신뢰성 등을 보장
      2. priority 로그 수준
         1. Emergency (emerg) : 시스템 전면 중단되는 패닉상태
         2. alert : 즉각적인 조치가 필요한 상황
         3. Critical (crit) : 하드웨어 등의 심각한 오류가 발생한 상황
         4. Error (err) : 일반적인 에러/오류가 발생한 상황
         5. Warning : 경고 메시지
         6. Notice : 에러/오류는 아니지만 조치가 필요한 상황
         7. Information (info) : 의미있는 정보 관련 메시지
         8. dubug : 디버깅용 메시지

### 5. 시스템 해킹

1. 버퍼 오버플로우 공격
   1. 개요 p106

## 2. Unix/Linux 서버 취약점

### 1. 계정 관리

### 2. 파일 및 디렉터리 관리

## 3. 윈도우 서버 취약점

### 1. 계정 관리

### 2. 서비스 관리

### 3. 로그 관리