# 시스템 보안

## 1. 시스템 기본학습

### 1. 윈도우 기본

#### 1. 윈도우 인증과정

![image-20210326193213610](https://user-images.githubusercontent.com/45009100/112626943-4599f400-8e74-11eb-8c41-36af09787f74.png)

1. 윈도우 인증 구성요소

   1. **LSA**(Local Security Authority)
      - 모든 계정의 로그인에 대한 검증 및 시스템 자원(파일)에 대한 **접근 권한을 검사**(로컬 및 원격 로그인)
      - 계정명과 SID(Security ID)를 매칭하여 SRM이 생성한 **감사 로그를 기록**
      - NT 보안의 중심 서비스이며 **보안 서브시스템**(Security Subsystem)이라고 불림
   2. **SAM**(Security Account Manager)
      - 사용자/그룹 **계정 정보에 대한 데이터베이스를 관리**
      - 사용자 로그인 정보와 SAM 파일에 저장된 사용자 패스워드 정보를 비교해 인증 여부를 결정
      - SAM 파일은 사용자,그룹 계정 및 암호화된 **패스워드 정보를 저장하고있는 데이터베이스**로
      - 윈도우 설치 디렉터리(c:\\innt 또는 c:\\Windows)에 위치함
   3. **SRM**(security Reference Monitor)
      - 인증된 사용자에게 **SID를 부여**
      - SID를 기반으로 하여 파일이나 디렉터리에 대한 **접근을 허용할지 여부를 결정**하고 이에 대한 **감사 메시지를 생성**

2. 로컬인증

   ![image-20210326194723616](https://user-images.githubusercontent.com/45009100/112626982-564a6a00-8e74-11eb-990a-f1950abfedbe.png)

3. 원격(도메인) 인증![image-20210326194953512](https://user-images.githubusercontent.com/45009100/112627014-62cec280-8e74-11eb-97a9-3c63886a5d22.png)

4. SAM 파일 접근 통제 설정(시스템 취약점 분석·평가 항목)

   1. SAM 파일은 사용자/그룹 계정의 패스워드를 관리하고 LSA를 통한 인증을 제공하는 중요한 파일이므로 접근통제 필요
   2. 공격자로부터 SAM 파일에 대한 패스워드 공격 시도에 따른 정보 노출의 위험이 있음
   3. 보안설정
      - Administrators 및 System 그룹 외에는 SAM 파일에 대한 접근을 제한
      - 불필요한 그룹 및 계정에 대해서는 권한을 제거

#### 2. 윈도우 보안 식별자(SID : Security ID)

1. 개요
   1. 윈도우의 각 사용자나 그룹에 부여되는 고유한 식별번호
   2. 사용자가 로그인을 수행하면 **액세스 토큰이 생성**되며, 해당 토큰에는 로그인한 사용자와 그 사용자가 속한 **모든 작업 그룹들에 관한 보안 식별자(SID) 정보가 담겨있음**
   3. 액세스 토큰의 사본은 그 사용자에 의해 시작된 모든 프로세스에 할당됨
   4. 사용자 계정 및 패스워드 정보를 담고있는 SAM 파일에 SID정보가 저장되어 있음
2. SID 구조
   1. 계정별 SID 구조
      - S-1-5-21-1700005937-0000000000-2235396725-1001
      - S-1 : 윈도우 시스템을 의미
      - 5-21 : 시스템이 도메인 컨트롤러 이러나 단독 시스템임을 의미
      - 1700005937-0000000000-2235396725 : 해당 시스템만의 고유한 식별자. 윈도우를 다시 설치해도 동일한 값을 가지지 않음
      - 500,501,1000
        - 500 : 관리자
        - 501 : 게스트
        - 1000 : 일반 사용자
   2. 실습
      - 윈도우 관리명령 콘솔(WMIC) 에서 확인 가능
      - cmd > wmic > useraccount list brief

#### 3. 윈도우 인증구조

![image-20210326202027193](https://user-images.githubusercontent.com/45009100/112627052-6febb180-8e74-11eb-99eb-a6654d15f2b0.png)

1. 개요
   1. 단순히 아이디와 패스워드를 전달하여 인증하는 방식은 정보 노출 및 패스워드 재사용공격에 취약
   2. 윈도우는 **Challenge & Response 방식** 의 인증구조를 사용
      1. 인증요청
         - 인증하고자 하는 사용자가 윈도우 시스템에 인증 요청
      2. Challenge 값 생성 및 전송
         - 인증 요청을 받은 서버는 특정 규칙 또는 랜덤한 Challenge 값을 생성하여 사용자에게 전달
      3. Response 값 생성 및 전송
         - 사용자는 전달받은 Challenge 값과 사용자 패스워드 정보를 이용해 Resonse 값을 생성하여 서버에 전달
      4. Response 값 확인 및 인증 성공
         - 사용자가 전달한 Response 값을 확인하여 인증 성공 여부를 전달
2. 인증암호 알고리즘
   1. LM(Lan Manager) 해시
      - 윈도우 2000,XP의 기본 알고리즘으로 구조적으로 취약
   2. NTLM 해시 
      -  LM 해시에 MD4 해시가 추가된 형태
   3. NTLMv2
      - 비스타 이후 윈도우 시스템의 기본 인증 프로토콜
      - 기존의 알고리즘과 전혀 다른 알고리즘으로 해시값을 생성, 크래킹이 어렵다
   4. Lan Manager는 네트워크를 통한 파일 및 프린터 공유 등과 같은 작업시 인증을 담당
   5. LM 인증 수준 설정을 통해 Challenge & Response 인증 프로토콜을 결정하면 NTLMv2 사용을 권장

#### 4. 패스워드 크래킹

1. 사전대입 공격(Dictionary Attack)
   - 패스워드로 자주 사용되는 사전에 있는 단어, 키보드 자판의 일련순 등 미리 사전(Dictionary) 파일로 만든 후 이를 하나씩 대입하는 방법
2. 무작위 대입 공격(Brute Force)
   - 패스워드에 사용될 수 있는 문자열의 범위를 정하고, 그 범위내에서 가능한 모든 패스워드를 대입
   - 일반적으로 사전공격 실패 후 무차별공격을 진행
3. 혼합 공격(hybrid Attack)
   - 사전대입 공격과 무작위 대입공격을 혼합한 방식
   - 사전파일에 있는 문자열에 문자, 숫자 등을 추가로 무작위 대입하는 크래킹 방법
   - 일반적으로 사전에 나오는 문자열 뒤에 숫자를 추가하는 형태의 패스워드가 많은점을 악용
4. 레인보우 테이블
   - 레인보우 테이블은 하나의 패스워드에서 시작해 특정한 변이함수를 이용해 여러 변이된 형태의 패스워드를 생성
   - 각 변이된 패스워드의 해시를 고리처럼 연결하여 일정 수의 패스워드와 해시로 이루어진 체인을 무수히 만들어 놓은 테이블
   - 해시 테이블과 R(Reduction)함수의 반복 수행을 통해 일치하는 해시값을  통해서 패스워드를 찾아내는 방식
   - 즉, 가능한 모든 해쉬값을 저장해 놓은 표. 해시로의 변환이 필요 없어 매우 빠름
   - 레인보우테이블로 인해 12자리의 숫자, 10자리의 소문자, 8자리의 숫자+소문자 정도는 순식간에 뚫을 수 있음
   - 방어법은
     - PBKDF2, Bcrypt,Scrypt 등의 적절한 알고리즘
     - 영어, 숫자, 특수문자를 조합한 긴 암호
     - 반복된 로그인 차단
     - 2-factor 인증
     - OTP 사용
     - Salted Hash



### 2. Unix/Linux 기본

#### 1. 시스템 기본

1. 시스템 접근

   1. 로그인 과정
      - 사용자 계정과 패스워드를 입력하면 로그인을 담당하는 프로그램은 입력한 패스워드와 /etc/passwd 파일의 해당 필드와 비교
      - 패스워드 확인 후 로그인 프로그램은 쉘이 사용할 변수들을 근거로 초기 환경을 설정. HOME, SHELL, USER, LOGNAME 변수들은 /etc/passwd파일에 기록된 정보로 값이 설정
        - HOME : 사용자의 홈 디렉터리 지정
        - SHELL : 로그인 쉘 지정
        - USER 또는 LOGNAME : 사용자의 사용자계정을 지정
      - 모든 절차가 끝나면 로그인 쉘 실행
      - 로그인 쉘은 일반적으로 etc/passwd 파일의 마지막 필드에 지정. 쉘은 사용자가 입력한 명령어를 해석하고 처리하는 기능을 함
   2. 로그아웃
      - 로그아웃 명령어는 logout 과 exit이 있고 [cntl + d] 조합으로도 가능

2. 사용자정보

   1. /etc/passwd 파일

      1. UNIX는 시스템 관리자가 사용자 계정을 만들 때마다 해당 사용자와 관련된 정보를 etc/passwd 파일에 저장

      2. passwd 파일에는 UNIX 시스템을 이용하는 데 필요한 기본 정보들이 담겨있음. 구분자 : 를 이용하여 7개의 필드로 구성

      3. 형식

         [1.user_account] : [2.user_password] : [3.user_id] : [4.group_id] : [5.comment] : [6.home_directory] : [7.login_shell]

         1. 사용자의 계정명
         2. 사용자 패스워드(x는 shadow 패스워드를 사용한다는 의미)
         3. 사용자 ID
         4. 그룹 ID
         5. 사용자 관련 기타 정보
         6. 로그인에 성공한 후에 사용자가 위치할 홈 디렉토리
         7. 로그인 쉘

      4. 해킹시 주로 3,4 번을 0으로 변경. root가 아니더라도 UID,GID가 0이 되면 root가 됨

      5. UID,GID가 0으로 변경된 계정이 있는지 주기적으로 관리해야 함. 또한 7번을 변경하여 악성 쉘이 실행되는 경우도 있음

   2. 사용자 확인

      1. UNIX 시스템에 접속중인 사용자를 확인하려면 id 명령을 사용
      2. 문법
         - id [user_account]
         - id만 하면 실행한 사용자 확인
         - id 뒤에 계정을 추가하면 계정의 id 확인

   3. 패스워드 변경

      1. 사용하던 패스워드를 변경하거나 패스워드가 없는 사용자에게 패스워드를 부여할 때 passwd명령을 사용
      2. 일반사용자는 자신의 패스워드만 변경,  root는 모든 사용자의 패스워드를 변경 가능
      3. 문법
         - passwd [user_account]

3. 그룹정보

   1. 그룹명과 그룹ID

      - 접근권한 및 보안 등의 관리를 위하여 사용자와 그룹에 대한 식별이 필요

      - 사용자ID와 그룹ID는 사용자와 그룹을 식별하는 시스템의 유일한 정수값

   2. 기본그룹과 보조그룹

      - UNIX 시스템은 자원의 소유주가 소속된 그룹에 별도의 접근권한을 지정할 수 있음
      - 같은 그룹에 소속된 사용자는 자원에 대하여 동일한 접근권한을 가짐
      - 하나의 기본그룹과 복수의 보조그룹에 소속될 수 있음
      - 기본그룹은 사용자가 자원 생성시 해당자원의 소유그룹을 지정하는 데 사용되며 etc/passwd 파일의 4번째 필드에 명시

   3. /etc/group 파일

      - 현재 시스템에 정의되어 있는 모든 그룹의 정보를 저장하고 있음

      - 형식

        	- [1.group_name] : [2.unvariable] : [3.group_id] : [4.user_account_entry_in_group]

        1. 그룹명
        2. 그룹의 암호화된 패스워드(사용안함)
        3. 기본그룹 ID로 그룹명을 대신하는 정수형 숫자
        4. 소속된 사용자 계정들

4. 입출력 재지정(I/O Redirection)

   - 입출력 대상으로 표준입력, 표준 출력, 표준 에러를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 말함
   - 키보드(표준입력)에서 들어오는 입력을 파일에서 받도록 대체하는 것을 입력재지정 이라고 함
   - 명령의 실행결과나 에러상황(표준출력,표준에러)을 화면에 출력하지 않고 파일로 대체하는 것을 출력 재지정
     - 입력 재지정 : command > file_name
     - 출력 재지정 : 
       1. command < file_name(파일 존재 시 새롭게 출력)
       2. command << file_name (파일 존재 시 추가하여 출력)

5. 파이프

   - 둘 이상의 명령을 함께 묶어 출력의 결과를 다른 프로그램의 입력으로 전환하는 기능
   - 명령어와 명령어 연결은 "|"를 사용하고, 선행 명령의 출력 데이터가 후행 명령의 입력데이터로 전달
   - command1 | command2 [ | command3 ...]

6. 특수문자

   - ~ : 홈 디렉터리
   - . : 현재 디렉터리
   - .. : 상위 디렉터리
   - ''#'': 주석
   - $ : 쉘 변수
   - & : 백그라운드 작업
   - "*" : 문자열 와일드 카드
   - ? : 한문자 와일드카드
     - ?는 한글자 *는 전체글자를 의미
     - ?a?는 가운데가 a인 세글자를 의미
     - a*a는 a로 시작하고 a로 끝나는 단어를 의미
   - ; : 쉘명령 구분자
   - | : 파이프
   - < : 입력 재지정
   - ">" : 출력재지정

#### 2. 파일시스템 응용

1. 파일시스템 개요

   1. 개요
      - 물리적인 저장장치에 파일을 생성, 저장, 관리하기 위한 논리적인 자료구조
      - 물리적인 디스크는 논리적인 파티션으로 나누어지며, 각각 파티션 별로 고유한 피일시스템을 생성
   2. 파일시스템 구정
      1. 부트블럭
         - 운영체제를 부팅하거나 초기화하기 위한 부트스트랩 코드를 담고있는 블럭
      2. 슈퍼블럭
         - 해당 파일시스템을 관리하기 위한 정보를 담고 있는 블럭
      3. 아이노드 리스트
         - 파일시스템 내에서 해당 파일을 식별하기 위한 고유한 식별자
         - 파일에 대한 속성 정보를 구조체 리스트로 이루어져 있음
         - i-node는 파일명이 없으며, 파일명은 디렉터리를 통해 관리
         - 침해사고 발생시 무결성 확인을 위해 타임라인 분석을 수행. inode의 mac 타임을 점검
           - Last Modification Time : 파일의 내용을 마지막으로 수정한 시간 
           - Last Access Time : 파일을 마지막으로 접근한 시간
           - Last Change Time : 파일의 속성을 마지막으로 변경한 시간
         - 특정 파일의 inode에 대한 속성정보는 stat 명령을 통해 확인
      4. 데이터 블럭
         - 실제 파일의 내용이 저장되는 블럭
         - 고정크기 block들로 이루어져 있다.

2. 파일시스템과 링크파일

   1. 개요
      - 링크는 윈도우의 바로가기 아이콘처험 기존 파일에 대한 또 다른 접근 포인트를 만들어 줌
      - 링크에는 하드링크와 심볼릭 링크가 있음
      - 문법
        - ln [-s] source_file | source_directory target_file
      - 하드링크는 파일에만 링크하고, 심볼릭 링크는 파일 또는 디렉토리에 링크함
   2. 하드링크
      - 하드링크는 기존 파일과 동일한 inode number를 가지는 파일을 생성하여 접근하는 방식
      - inode number는 파일시스템 별로 고유한 값이기 때문에 동일 파일시스템 내에서만 하드링크가 가능하고, 디렉터리는 하드링크가 불가능함
      - inode를 참조하는 파일이 있으면 삭제하지 않음
      - stat 을 통해 inode 정보를 확인
   3. 심볼릭 링크
      - 동일한 파일시스템 내에서만 링크가 가능한 하드링크의 단점을 보완
      - 원본 파일에 대한 파일 경로를 파일내용으로 하는 새로운 파일을 생성해서 접근
      - 하드링크와 달리 파일경로를 기반으로 하므로 파일시스템에 제한이 없고 디렉터리도 가능
      - 원본파일이 삭제되거나 이동하게 되면 해당 경로가 바뀌게 되므로 링크가 끊어짐

3. 디렉터리 관리

   1. 파일의 종류
      1. 일반 파일 
         -  일반적으로 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 되어있음
         - 정규파일은 표준 파일 입출력 시스템 호출을 통해 참조
      2. 디렉터리
         - 디렉터리에 포함된 파일명과 해당 파일에 대한 정보를 담고있는 inode number 목록을 내용으로 가지고 있는 특수한 파일
      3. 특수파일
         - 기능에 따라 다양한 형태로 존재
         - 프로세스 간 통신을 위해 **파이프**, **소켓** 등의 파일을 사용
         - 디스크, 프린터, 터미널, 키보드 등의 주변장치를 사용하기 위한 **장치파일**
         - 장치파일은 블럭단위로 입출력하는 블럭 장치 파일(버퍼링)과 문자단위로 입출력하는 문자 장치 파일(비 버퍼링)으로 구분
   2. 디렉터리 내용 출력(ls 명령)
      - 특정 디렉터리에 있는 파일 목록을 보여주고 옵션 정보를 보여줌
      - 디렉터리에는 파일명과 해당 파일의 inode number에 대한 매핑정보만 가지고 있으며, 상세정보를 볼 수 있는 것은 inode number를 통해 inode 구조체 정보를 참조하기 때문
   3. 디렉터리 간의 이동 (cd 명령)
      - change directory
   4. 새로운 디렉터리 생성(mkdir 명령)
   5. 기존 디렉터리 삭제(rmdir 명령)
      - 디렉터리 하위에 디렉터리나 파일이 없어야 함

4. 파일권한 관리

   1. 접근권한 변경(chmod 명령)
      - 기존 파일 또는 디렉터리에 대한 접근권한을 변경할 때 사용
      - 접근권한을 기호로 기술하는 방법
        - 대상 : u(user), g(group), o(others) , a(all)
        - 연산자 : +(추가), -(제거), =(지정)
        - 접근권한 : r,w,x
      - 접근권한을 숫자로 기술하는 방법
        - 읽기 = 4, 쓰기 = 2, 실행 = 1
        - 644 : user는 읽기&쓰기 , group과 others는 읽기만 가능
   2. 소유주 또는 소유그룹 변경(chown / chgrp)
      - root는 모든 소유자/소유그룹 변경 가능
   3. 접근권한 마스크(umask)
      - 기존 파일의 접근권한을 변경할 때 사용. 8진수로 해당 파일의 권한을 명시
      - 8진수의 의미는 새로 만들어질 파일에서 제거 될 권한을 명시
      - 즉, umask 022로 설정하면 생성되는 파일은 666 - 022 인 644의 권한으로 생성됨

5. 파일검색 (find)

   - find명령은 시스템 내에있는 파일 중에서 사용자가 원하는 파일을 찾을 때 사용
   - 단순히 찾을 뿐만 아니라 특정 명령을 실행하도록 명력할 수 있어서 편리함

   1. 주요 옵션 실습
      1. 퍼미션 관련
         - -perm [-]mode : -가 없으면 정확히 모드 권한과 일치하는 파일, -가 있으면 mode 권한을 포함하는 파일을 검색
         - -perm 4000 이면 setuid만 설정되어 있는 파일을 검색하고, -4000이면 setuid를 포함하는 파일을 검색
         - -exec 옵션을 통해 추가적인 명령을 싱행
         - 검색조건이 둘 이상일 경우 -o(or) -a(and)의 논리연산 및 ()를 추가하여 우선순위 지정
      2. **시간 관련 실습**
         - 파일 시간 속성에 따라 atime(accss time), mtime(moditication time), ctime(change time) 으로 구분
         - -mtime [+-]n : +-가 없으면 정확이 n일, +n이면 n일 초과, -n이면 n일 미만인  파일을 검색
         - -mtime -4 이면 마지막 수정일이 4일 미만인 파일을 검색
      3. 크기 관련 실습
         - size [+-]n : 사이즈가 초과/미만인 파일을 검색
         - size +3M : 크기가 3Mbytes를 초과하는 파일을 검색

#### 3. 프로세스 응용

1. 프로세스 개요
   1. 개요
      1. 프로세스가 생성되면 커널/운영체제는 개별 프로세스별로 관리정보를 담고있는 프로세스 제어 블럭 PCB를 생성
         - 프로세스 상태 : 프로세스의 현재 상태정보를 저장
         - 프로세스 번호 : 프로세스를 식별하기 위한 번호ID
         - 프로그램 카운터 : 문맥교환이 발생할 경우 다음에 실행할 명령어의 위치를 저장
         - 레지스터 : 문맥교환이 발생할 경우 현재 프로세스의 실행 상태정보를 저장
         - 메모리 정보 : 프로세스가 사용하는 메모리 page 또는 segment 테이블 정보
      2. 프로세스가 생성되면 개별 프로세스별로 오픈한 파일을 관리하기 위한 파일 디스크립터 테이블(FDT)이 생성된다
         - 기본적으로 3개의 파일이 자동 오픈됨. 표준입력, 표준출력, 표준에러
         - 프로세스 내에서 오픈한 각각의 파일을 식별하기 위한 양의 정수값을 파일 디스크립터라고 함
      3. 커널/운여영체제가 시스템 내에서 여러 프로세스들에 의해 오픈된 파일들을 관리하기 위한 자료구조가 System open-file tables
         - open_mode : 파일의 읽기/쓰기 모드
         - offset : 현재 파일 I/O를 수행하기 위한 위치값
         - reference_count : 해당 파일의 참조 개수를 의미. 파일 복제가 발생하면 count가 증가
      4. Active vnode table은 해당 파일의 inode 정보를 가지고 있는 일종의 캐시역할을 함

### 3. Unix/Linux 시스템 관리

1. 시스템 시작과 종료
   1. 부팅관련 용어 정의
      1. Run Level
         - 시스템에서 런레벨의 의미는 시스템의 운영상태를 숫자 혹은 문자로 표현
         - init 프로세스는 /etc/inittab 파일에 정의된 런 레벨에 따라 디렉터리에 나열도니 스크립트를 실행하여 시스템의 운영상태를 구성
         - 각 런레벨이 의미하는 시스템의 운영상태
           - 0 : PROM(Programmable Read-Only Memory)
           - S,s : 시스템 싱글 유저 모드, 로컬 파일 시스템이 마운트되지 않은 상태
           - 1 : 시스템 싱글 유저 모드, 로클 파일 시스템이 마운트된 상태
           - 2 : 멀티유저 모드 (NFS 클라이언트 모드)
           - 3 : 멀티유저 모드 (NFS 서버 모드), UNIX 기본 Run Level
           - 4 : 사용안함
           - 5 : 시스템 power off 모드
           - 6 : 시스템 리부팅
         - 서버용 Unix 시스템은 일반적으로 3 또는 5의 런레벨로 운영됨
         - 현재 운영중이 런레벨을 알고슾은 경우 who -r 또는 runlevel 명령
      2. INIT 상태
         - 시스템 런레벨을 이동할 때, init 명령어를 통해 이동
         - 현재 멀티유저모드인 3인데, 싱글모드로 이동하고 싶은 경우 'init s' 명령어를 이용
   2. 시스템 시작
      1. 바이오스 과정
         - 시스템에 전원이 들어오면 바이오스는 시스템의 기본적인 하드웨어의 이상유무를 점검하고 시스템의 하드웨어 정보를 수집
      2. 부트 프로그램 과정
         - 부트 프로그램은 하드디스크에서 커널을 읽어 들여 메모리상에 적재하고 시스템 제어권을 커널에 넘김
      3. 커널 과정
         - 커널이 메모리상에 적재되면 그때부터 운영체제가 구동되기 시작
         - 커널은 부팅과정의 일부인 하드웨어 점검을 완료하고 내부 자료구조를 초기화하여 시스템을 운영하기 위한 부가적인 커널 모듈을 하드디스크에서 메모리 상으로 적재함
      4. init 프로세스 과정
         - init 프로세스는 커널에 의해 생성되는 첫 프로세스
         - 부팅과정에서 사용자가 시스템을 사용할 수 있게 하는 초기화 담당
         - 런레벨이라고 함
2. 사용자 관리
   1. 사용자 계정 추가
      - 사용자 계정정보를 저장하는 /etc/passwd 와 암호를 저장하는 /etc/shadow에 사용자정보를 저장
      - 새 사용자를 위한 홈 디렉터리를 생성하고 접근권한 부여
      - 사용자 로그인에 필요한 시작파일을 홈 디렉터에 생성
3. 파일시스템 관리
   1. 파일시스템 연결
      - 보조기억장치에 들어있는 데이터를 읽어오고, 저장하려면 UNIX시스템에 연결해야 함
      - mount 명령으로 보조기억장치를 UNIX 시스템이 인식하도록 특정 디렉터리에 논리적으로 연결
4. 프로세스 스케줄관리
   1. 정기적 스케줄관리(cron)
      1. 개요
         1. cron 데몬 프로세스는 시스템에서 정기적인 작업을 지정시간에 처리하기 위해 사용
         2. 데몬 프로세스를 통한 처리가 효율적인 작업
            - 일괄적으로 처리해야 하는 작업(특히 야간작업)
            - 작업에 대한 요구가 불규칙하지 않은 경우
            - 우선순위가 낮은 작업을 일정시기에 처리해야 하는 경우
            - 작업 빈도가 낮아서 필요시점에 처리하는 것이 효율적
         3. cron 데몬 프로세스를 사용하려면 세가지 구성요소가 필요
            1. 정기적으로 처리할 작업 목록을 정의한 crontab 파일
            2. crontab 파일을 제어하는 crontab 명령
            3. crontab 파일을 읽어서 내용에 정의된 대로 작업을 처리하는 cron 데몬 프로세스
      2. crontab 파일의 구조
         1. crontab 파일의 각 행은 space나 tab 키로 구분된 6개의 필드
            1. 필드1 : 분
            2. 필드2 : 시
            3. 필드3 : 일
            4. 필드4 : 월
            5. 필드5 : 요일
            6. 필드6 : 작업
      3. crontab 파일의 제어
         1. crontab 파일은 사용자 계정별로 만듦
         2. 시스템 관리자인 root는 다른 사용자의 crontab 파일을 편집할 수 있음
         3. 입력문법
            - 리눅스 : $crontab -u algisa (-e | -l | -r )  (편집,출력, 삭제)
            - 유닉스 : $crontab (-e | -l| -r) algisa
            - 자신의 계정 : $crontab (-e | -l | -r)
      4. crontab 명령 접근제어
         1. crontab 명령을 실행할 수 있는 사용자를 제한하여 임의로 등록하지 못하게 함
         2. crontab 명령 접근 제어를 위해 /etc/cron.allow , /etc/cron.deny 설정파일을 사용
         3. cron.allow 는 등록된 사용자만 명령을 실행하는 화이트리스트 방식
         4. cron.deny는 등록된 사용자만 할 수 없는 블랙리스트 방식
         5. 두 파일이 모두 존재하는 경우 cron.allow를 우선으로 함
         6. 두 파일 모두 없는 경우 root만 명령을 실행할 수 있음
   2. 일시적 스케줄관리(at)
      - 한번만 실행, 처리된 작업은 작업 목록에서 삭제

### 4. Unix/Linux 서버 보안

1. 시스템 보안
   1. 사용자의 패스워드 관리
      1. 개요
         - passwd 파일은 시스템에 등록된 사용자 정보가 담겨있음
         - 패스워드 저장정책에는 passwd와 shadow 가 있음
         - 과거에는 passwd파일의 두번째 필드에 저장했으나, 최근에는 shadow 파일에 암호화된 패스워드를 저장하고 root만 접근가능
      2. passwd 파일
         - 사용자 로그인 쉘 점검
         - 사용자의 로그인 쉘을 /sbin/nologin 또는 /bin/false 로 설정
      3. shadow( etc/shadow) 파일 (리눅스 기준)
         1.  개요
            - 패스워드 정보를 평문으로 저장할 경우 유출 피해가 발생할 수 있음
            - 따라서 암호화하여 저장하고 root만 접근 가능하도록 함
         2. /etc/shadow 파일 형식
            1. user_account : 사용자 계정명
            2. encrypted_password : 암호화된 패스워드
            3. last_change : 1970년 1월 1일 기준으로 마지막으로 패스워드를 변경한 일 수
            4. minlife : 패스워드 최소 사용기간 설정. 익숙한 암호 재사용 방지 7일 권장
            5. maxlife : 패스워드 최대 사용기간 설정. 패스워드 만료일수 90일 권장
            6. warn : 패스워드 만료이전 경고 일수
            7. inactive : 패스워드가 만료된 이후 계정이 잠기기 전까지 비활성 일수
            8. expires : 계정 만료일 설정 1970년 1월 1일 기준으로 일수로 표시
         3. encrypted_password 필드 구성
            - ID,Salt,encrypted_password 형식으로 구성
            - 66p

### 5. 시스템 해킹

## 2. Unix/Linux 서버 취약점

### 1. 계정 관리

### 2. 파일 및 디렉터리 관리

## 3. 윈도우 서버 취약점

### 1. 계정 관리

### 2. 서비스 관리

### 3. 로그 관리