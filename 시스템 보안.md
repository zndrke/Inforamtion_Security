# 시스템 보안

## 1. 시스템 기본학습

### 1. 윈도우 기본

#### 1. 윈도우 인증과정

![image-20210326193213610](https://user-images.githubusercontent.com/45009100/112626943-4599f400-8e74-11eb-8c41-36af09787f74.png)

1. 윈도우 인증 구성요소

   1. **LSA**(Local Security Authority)
      - 모든 계정의 로그인에 대한 검증 및 시스템 자원(파일)에 대한 **접근 권한을 검사**(로컬 및 원격 로그인)
      - 계정명과 SID(Security ID)를 매칭하여 SRM이 생성한 **감사 로그를 기록**
      - NT 보안의 중심 서비스이며 **보안 서브시스템**(Security Subsystem)이라고 불림
   2. **SAM**(Security Account Manager)
      - 사용자/그룹 **계정 정보에 대한 데이터베이스를 관리**
      - 사용자 로그인 정보와 SAM 파일에 저장된 사용자 패스워드 정보를 비교해 인증 여부를 결정
      - SAM 파일은 사용자,그룹 계정 및 암호화된 **패스워드 정보를 저장하고있는 데이터베이스**로
      - 윈도우 설치 디렉터리(c:\\innt 또는 c:\\Windows)에 위치함
   3. **SRM**(security Reference Monitor)
      - 인증된 사용자에게 **SID를 부여**
      - SID를 기반으로 하여 파일이나 디렉터리에 대한 **접근을 허용할지 여부를 결정**하고 이에 대한 **감사 메시지를 생성**

2. 로컬인증

   ![image-20210326194723616](https://user-images.githubusercontent.com/45009100/112626982-564a6a00-8e74-11eb-990a-f1950abfedbe.png)

3. 원격(도메인) 인증![image-20210326194953512](https://user-images.githubusercontent.com/45009100/112627014-62cec280-8e74-11eb-97a9-3c63886a5d22.png)

4. SAM 파일 접근 통제 설정(시스템 취약점 분석·평가 항목)

   1. SAM 파일은 사용자/그룹 계정의 패스워드를 관리하고 LSA를 통한 인증을 제공하는 중요한 파일이므로 접근통제 필요
   2. 공격자로부터 SAM 파일에 대한 패스워드 공격 시도에 따른 정보 노출의 위험이 있음
   3. 보안설정
      - Administrators 및 System 그룹 외에는 SAM 파일에 대한 접근을 제한
      - 불필요한 그룹 및 계정에 대해서는 권한을 제거

#### 2. 윈도우 보안 식별자(SID : Security ID)

1. 개요
   1. 윈도우의 각 사용자나 그룹에 부여되는 고유한 식별번호
   2. 사용자가 로그인을 수행하면 **액세스 토큰이 생성**되며, 해당 토큰에는 로그인한 사용자와 그 사용자가 속한 **모든 작업 그룹들에 관한 보안 식별자(SID) 정보가 담겨있음**
   3. 액세스 토큰의 사본은 그 사용자에 의해 시작된 모든 프로세스에 할당됨
   4. 사용자 계정 및 패스워드 정보를 담고있는 SAM 파일에 SID정보가 저장되어 있음
2. SID 구조
   1. 계정별 SID 구조
      - S-1-5-21-1700005937-0000000000-2235396725-1001
      - S-1 : 윈도우 시스템을 의미
      - 5-21 : 시스템이 도메인 컨트롤러 이러나 단독 시스템임을 의미
      - 1700005937-0000000000-2235396725 : 해당 시스템만의 고유한 식별자. 윈도우를 다시 설치해도 동일한 값을 가지지 않음
      - 500,501,1000
        - 500 : 관리자
        - 501 : 게스트
        - 1000 : 일반 사용자
   2. 실습
      - 윈도우 관리명령 콘솔(WMIC) 에서 확인 가능
      - cmd > wmic > useraccount list brief

#### 3. 윈도우 인증구조

![image-20210326202027193](https://user-images.githubusercontent.com/45009100/112627052-6febb180-8e74-11eb-99eb-a6654d15f2b0.png)

1. 개요
   1. 단순히 아이디와 패스워드를 전달하여 인증하는 방식은 정보 노출 및 패스워드 재사용공격에 취약
   2. 윈도우는 **Challenge & Response 방식** 의 인증구조를 사용
      1. 인증요청
         - 인증하고자 하는 사용자가 윈도우 시스템에 인증 요청
      2. Challenge 값 생성 및 전송
         - 인증 요청을 받은 서버는 특정 규칙 또는 랜덤한 Challenge 값을 생성하여 사용자에게 전달
      3. Response 값 생성 및 전송
         - 사용자는 전달받은 Challenge 값과 사용자 패스워드 정보를 이용해 Resonse 값을 생성하여 서버에 전달
      4. Response 값 확인 및 인증 성공
         - 사용자가 전달한 Response 값을 확인하여 인증 성공 여부를 전달
2. 인증암호 알고리즘
   1. LM(Lan Manager) 해시
      - 윈도우 2000,XP의 기본 알고리즘으로 구조적으로 취약
   2. NTLM 해시 
      -  LM 해시에 MD4 해시가 추가된 형태
   3. NTLMv2
      - 비스타 이후 윈도우 시스템의 기본 인증 프로토콜
      - 기존의 알고리즘과 전혀 다른 알고리즘으로 해시값을 생성, 크래킹이 어렵다
   4. Lan Manager는 네트워크를 통한 파일 및 프린터 공유 등과 같은 작업시 인증을 담당
   5. LM 인증 수준 설정을 통해 Challenge & Response 인증 프로토콜을 결정하면 NTLMv2 사용을 권장

#### 4. 패스워드 크래킹

1. 사전대입 공격(Dictionary Attack)
   - 패스워드로 자주 사용되는 사전에 있는 단어, 키보드 자판의 일련순 등 미리 사전(Dictionary) 파일로 만든 후 이를 하나씩 대입하는 방법
2. 무작위 대입 공격(Brute Force)
   - 패스워드에 사용될 수 있는 문자열의 범위를 정하고, 그 범위내에서 가능한 모든 패스워드를 대입
   - 일반적으로 사전공격 실패 후 무차별공격을 진행
3. 혼합 공격(hybrid Attack)
   - 사전대입 공격과 무작위 대입공격을 혼합한 방식
   - 사전파일에 있는 문자열에 문자, 숫자 등을 추가로 무작위 대입하는 크래킹 방법
   - 일반적으로 사전에 나오는 문자열 뒤에 숫자를 추가하는 형태의 패스워드가 많은점을 악용
4. 레인보우 테이블
   - 레인보우 테이블은 하나의 패스워드에서 시작해 특정한 변이함수를 이용해 여러 변이된 형태의 패스워드를 생성
   - 각 변이된 패스워드의 해시를 고리처럼 연결하여 일정 수의 패스워드와 해시로 이루어진 체인을 무수히 만들어 놓은 테이블
   - 해시 테이블과 R(Reduction)함수의 반복 수행을 통해 일치하는 해시값을  통해서 패스워드를 찾아내는 방식
   - 즉, 가능한 모든 해쉬값을 저장해 놓은 표. 해시로의 변환이 필요 없어 매우 빠름
   - 레인보우테이블로 인해 12자리의 숫자, 10자리의 소문자, 8자리의 숫자+소문자 정도는 순식간에 뚫을 수 있음
   - 방어법은
     - PBKDF2, Bcrypt,Scrypt 등의 적절한 알고리즘
     - 영어, 숫자, 특수문자를 조합한 긴 암호
     - 반복된 로그인 차단
     - 2-factor 인증
     - OTP 사용
     - Salted Hash



### 2. Unix/Linux 기본

#### 1. 시스템 기본

1. 시스템 접근

   1. 로그인 과정
      - 사용자 계정과 패스워드를 입력하면 로그인을 담당하는 프로그램은 입력한 패스워드와 /etc/passwd 파일의 해당 필드와 비교
      - 패스워드 확인 후 로그인 프로그램은 쉘이 사용할 변수들을 근거로 초기 환경을 설정. HOME, SHELL, USER, LOGNAME 변수들은 /etc/passwd파일에 기록된 정보로 값이 설정
        - HOME : 사용자의 홈 디렉터리 지정
        - SHELL : 로그인 쉘 지정
        - USER 또는 LOGNAME : 사용자의 사용자계정을 지정
      - 모든 절차가 끝나면 로그인 쉘 실행
      - 로그인 쉘은 일반적으로 etc/passwd 파일의 마지막 필드에 지정. 쉘은 사용자가 입력한 명령어를 해석하고 처리하는 기능을 함
   2. 로그아웃
      - 로그아웃 명령어는 logout 과 exit이 있고 [cntl + d] 조합으로도 가능

2. 사용자정보

   1. /etc/passwd 파일

      1. UNIX는 시스템 관리자가 사용자 계정을 만들 때마다 해당 사용자와 관련된 정보를 etc/passwd 파일에 저장

      2. passwd 파일에는 UNIX 시스템을 이용하는 데 필요한 기본 정보들이 담겨있음. 구분자 : 를 이용하여 7개의 필드로 구성

      3. 형식

         [1.user_account] : [2.user_password] : [3.user_id] : [4.group_id] : [5.comment] : [6.home_directory] : [7.login_shell]

         1. 사용자의 계정명
         2. 사용자 패스워드(x는 shadow 패스워드를 사용한다는 의미)
         3. 사용자 ID
         4. 그룹 ID
         5. 사용자 관련 기타 정보
         6. 로그인에 성공한 후에 사용자가 위치할 홈 디렉토리
         7. 로그인 쉘

      4. 해킹시 주로 3,4 번을 0으로 변경. root가 아니더라도 UID,GID가 0이 되면 root가 됨

      5. UID,GID가 0으로 변경된 계정이 있는지 주기적으로 관리해야 함. 또한 7번을 변경하여 악성 쉘이 실행되는 경우도 있음

   2. 사용자 확인

      1. UNIX 시스템에 접속중인 사용자를 확인하려면 id 명령을 사용
      2. 문법
         - id [user_account]
         - id만 하면 실행한 사용자 확인
         - id 뒤에 계정을 추가하면 계정의 id 확인

   3. 패스워드 변경

      1. 사용하던 패스워드를 변경하거나 패스워드가 없는 사용자에게 패스워드를 부여할 때 passwd명령을 사용
      2. 일반사용자는 자신의 패스워드만 변경,  root는 모든 사용자의 패스워드를 변경 가능
      3. 문법
         - passwd [user_account]

3. 그룹정보

   1. 그룹명과 그룹ID

      - 접근권한 및 보안 등의 관리를 위하여 사용자와 그룹에 대한 식별이 필요

      - 사용자ID와 그룹ID는 사용자와 그룹을 식별하는 시스템의 유일한 정수값

   2. 기본그룹과 보조그룹

      - UNIX 시스템은 자원의 소유주가 소속된 그룹에 별도의 접근권한을 지정할 수 있음
      - 같은 그룹에 소속된 사용자는 자원에 대하여 동일한 접근권한을 가짐
      - 하나의 기본그룹과 복수의 보조그룹에 소속될 수 있음
      - 기본그룹은 사용자가 자원 생성시 해당자원의 소유그룹을 지정하는 데 사용되며 etc/passwd 파일의 4번째 필드에 명시

   3. /etc/group 파일

      - 현재 시스템에 정의되어 있는 모든 그룹의 정보를 저장하고 있음

      - 형식

        	- [1.group_name] : [2.unvariable] : [3.group_id] : [4.user_account_entry_in_group]

        1. 그룹명
        2. 그룹의 암호화된 패스워드(사용안함)
        3. 기본그룹 ID로 그룹명을 대신하는 정수형 숫자
        4. 소속된 사용자 계정들

4. 입출력 재지정(I/O Redirection)

   - 입출력 대상으로 표준입력, 표준 출력, 표준 에러를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 말함
   - 키보드(표준입력)에서 들어오는 입력을 파일에서 받도록 대체하는 것을 입력재지정 이라고 함
   - 명령의 실행결과나 에러상황(표준출력,표준에러)을 화면에 출력하지 않고 파일로 대체하는 것을 출력 재지정
     - 입력 재지정 : command > file_name
     - 출력 재지정 : 
       1. command < file_name(파일 존재 시 새롭게 출력)
       2. command << file_name (파일 존재 시 추가하여 출력)

5. 파이프

   - 둘 이상의 명령을 함께 묶어 출력의 결과를 다른 프로그램의 입력으로 전환하는 기능
   - 명령어와 명령어 연결은 "|"를 사용하고, 선행 명령의 출력 데이터가 후행 명령의 입력데이터로 전달
   - command1 | command2 [ | command3 ...]

6. 특수문자

   - ~ : 홈 디렉터리
   - . : 현재 디렉터리
   - .. : 상위 디렉터리
   - ''#'': 주석
   - $ : 쉘 변수
   - & : 백그라운드 작업
   - "*" : 문자열 와일드 카드
   - ? : 한문자 와일드카드
     - ?는 한글자 *는 전체글자를 의미
     - ?a?는 가운데가 a인 세글자를 의미
     - a*a는 a로 시작하고 a로 끝나는 단어를 의미
   - ; : 쉘명령 구분자
   - | : 파이프
   - < : 입력 재지정
   - ">" : 출력재지정

#### 2. 파일시스템 응용

1. 파일시스템 개요

   1. 개요
      - 물리적인 저장장치에 파일을 생성, 저장, 관리하기 위한 논리적인 자료구조
      - 물리적인 디스크는 논리적인 파티션으로 나누어지며, 각각 파티션 별로 고유한 피일시스템을 생성
   2. 파일시스템 구정
      1. 부트블럭
         - 운영체제를 부팅하거나 초기화하기 위한 부트스트랩 코드를 담고있는 블럭
      2. 슈퍼블럭
         - 해당 파일시스템을 관리하기 위한 정보를 담고 있는 블럭
      3. 아이노드 리스트
         - 파일시스템 내에서 해당 파일을 식별하기 위한 고유한 식별자
         - 파일에 대한 속성 정보를 구조체 리스트로 이루어져 있음
         - i-node는 파일명이 없으며, 파일명은 디렉터리를 통해 관리
         - 침해사고 발생시 무결성 확인을 위해 타임라인 분석을 수행. inode의 mac 타임을 점검
           - Last Modification Time : 파일의 내용을 마지막으로 수정한 시간 
           - Last Access Time : 파일을 마지막으로 접근한 시간
           - Last Change Time : 파일의 속성을 마지막으로 변경한 시간
         - 특정 파일의 inode에 대한 속성정보는 stat 명령을 통해 확인
      4. 데이터 블럭
         - 실제 파일의 내용이 저장되는 블럭
         - 고정크기 block들로 이루어져 있다.

2. 파일시스템과 링크파일

   1. 개요
      - 링크는 윈도우의 바로가기 아이콘처험 기존 파일에 대한 또 다른 접근 포인트를 만들어 줌
      - 링크에는 하드링크와 심볼릭 링크가 있음
      - 문법
        - ln [-s] source_file | source_directory target_file
      - 하드링크는 파일에만 링크하고, 심볼릭 링크는 파일 또는 디렉토리에 링크함
   2. 하드링크
      - 하드링크는 기존 파일과 동일한 inode number를 가지는 파일을 생성하여 접근하는 방식
      - inode number는 파일시스템 별로 고유한 값이기 때문에 동일 파일시스템 내에서만 하드링크가 가능하고, 디렉터리는 하드링크가 불가능함
      - inode를 참조하는 파일이 있으면 삭제하지 않음
      - stat 을 통해 inode 정보를 확인
   3. 심볼릭 링크
      - 동일한 파일시스템 내에서만 링크가 가능한 하드링크의 단점을 보완
      - 원본 파일에 대한 파일 경로를 파일내용으로 하는 새로운 파일을 생성해서 접근
      - 하드링크와 달리 파일경로를 기반으로 하므로 파일시스템에 제한이 없고 디렉터리도 가능
      - 원본파일이 삭제되거나 이동하게 되면 해당 경로가 바뀌게 되므로 링크가 끊어짐

3. 디렉터리 관리

   1. 파일의 종류
      1. 일반 파일 
         -  일반적으로 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 되어있음
         - 정규파일은 표준 파일 입출력 시스템 호출을 통해 참조
      2. 디렉터리
         - 디렉터리에 포함된 파일명과 해당 파일에 대한 정보를 담고있는 inode number 목록을 내용으로 가지고 있는 특수한 파일
      3. 특수파일
         - 기능에 따라 다양한 형태로 존재
         - 프로세스 간 통신을 위해 **파이프**, **소켓** 등의 파일을 사용
         - 디스크, 프린터, 터미널, 키보드 등의 주변장치를 사용하기 위한 **장치파일**
         - 장치파일은 블럭단위로 입출력하는 블럭 장치 파일(버퍼링)과 문자단위로 입출력하는 문자 장치 파일(비 버퍼링)으로 구분
   2. 디렉터리 내용 출력(ls 명령)
      - 특정 디렉터리에 있는 파일 목록을 보여주고 옵션 정보를 보여줌
      - 디렉터리에는 파일명과 해당 파일의 inode number에 대한 매핑정보만 가지고 있으며, 상세정보를 볼 수 있는 것은 inode number를 통해 inode 구조체 정보를 참조하기 때문
   3. 디렉터리 간의 이동 (cd 명령)
      - change directory
   4. 새로운 디렉터리 생성(mkdir 명령)
   5. 기존 디렉터리 삭제(rmdir 명령)
      - 디렉터리 하위에 디렉터리나 파일이 없어야 함

4. 파일권한 관리

   1. 접근권한 변경(chmod 명령)
      - 기존 파일 또는 디렉터리에 대한 접근권한을 변경할 때 사용
      - 접근권한을 기호로 기술하는 방법
        - 대상 : u(user), g(group), o(others) , a(all)
        - 연산자 : +(추가), -(제거), =(지정)
        - 접근권한 : r,w,x
      - 접근권한을 숫자로 기술하는 방법
        - 읽기 = 4, 쓰기 = 2, 실행 = 1
        - 644 : user는 읽기&쓰기 , group과 others는 읽기만 가능
   2. 소유주 또는 소유그룹 변경(chown / chgrp)
      - root는 모든 소유자/소유그룹 변경 가능
   3. 접근권한 마스크(umask)
      - 기존 파일의 접근권한을 변경할 때 사용. 8진수로 해당 파일의 권한을 명시
      - 8진수의 의미는 새로 만들어질 파일에서 제거 될 권한을 명시
      - 즉, umask 022로 설정하면 생성되는 파일은 666 - 022 인 644의 권한으로 생성됨

5. 파일검색 (find)

   - find명령은 시스템 내에있는 파일 중에서 사용자가 원하는 파일을 찾을 때 사용
   - 단순히 찾을 뿐만 아니라 특정 명령을 실행하도록 명력할 수 있어서 편리함

   1. 주요 옵션 실습
      1. 퍼미션 관련
         - -perm [-]mode : -가 없으면 정확히 모드 권한과 일치하는 파일, -가 있으면 mode 권한을 포함하는 파일을 검색
         - -perm 4000 이면 setuid만 설정되어 있는 파일을 검색하고, -4000이면 setuid를 포함하는 파일을 검색
         - -exec 옵션을 통해 추가적인 명령을 싱행
         - 검색조건이 둘 이상일 경우 -o(or) -a(and)의 논리연산 및 ()를 추가하여 우선순위 지정
      2. **시간 관련 실습**
         - 파일 시간 속성에 따라 atime(accss time), mtime(moditication time), ctime(change time) 으로 구분
         - -mtime [+-]n : +-가 없으면 정확이 n일, +n이면 n일 초과, -n이면 n일 미만인  파일을 검색
         - -mtime -4 이면 마지막 수정일이 4일 미만인 파일을 검색
      3. 크기 관련 실습
         - size [+-]n : 사이즈가 초과/미만인 파일을 검색
         - size +3M : 크기가 3Mbytes를 초과하는 파일을 검색

#### 3. 프로세스 응용

### 3. Unix/Linux 시스템 관리

### 4. Unix/Linux 서버 보안

### 5. 시스템 해킹

## 2. Unix/Linux 서버 취약점

### 1. 계정 관리

### 2. 파일 및 디렉터리 관리

## 3. 윈도우 서버 취약점

### 1. 계정 관리

### 2. 서비스 관리

### 3. 로그 관리